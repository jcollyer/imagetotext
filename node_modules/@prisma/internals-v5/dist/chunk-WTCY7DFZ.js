"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_WTCY7DFZ_exports = {};
__export(chunk_WTCY7DFZ_exports, {
  getPackedPackage: () => getPackedPackage,
  require_p_map: () => require_p_map
});
module.exports = __toCommonJS(chunk_WTCY7DFZ_exports);
var import_chunk_WIPBZJFE = require("./chunk-WIPBZJFE.js");
var import_chunk_ENSUX2GR = require("./chunk-ENSUX2GR.js");
var import_chunk_KXIPL557 = require("./chunk-KXIPL557.js");
var import_chunk_RXZEDVTJ = require("./chunk-RXZEDVTJ.js");
var import_chunk_G3BTRIWS = require("./chunk-G3BTRIWS.js");
var import_chunk_JD7BZWTA = require("./chunk-JD7BZWTA.js");
var import_chunk_UWXPWM6Q = require("./chunk-UWXPWM6Q.js");
var import_chunk_PN7UG7JB = require("./chunk-PN7UG7JB.js");
var import_chunk_FVJ3R4NJ = require("./chunk-FVJ3R4NJ.js");
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var require_lib = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/npm-normalize-package-bin@2.0.0/node_modules/npm-normalize-package-bin/lib/index.js"(exports, module2) {
    "use strict";
    var { join, basename } = (0, import_chunk_FVJ3R4NJ.__require)("path");
    var normalize = (pkg) => !pkg.bin ? removeBin(pkg) : typeof pkg.bin === "string" ? normalizeString(pkg) : Array.isArray(pkg.bin) ? normalizeArray(pkg) : typeof pkg.bin === "object" ? normalizeObject(pkg) : removeBin(pkg);
    var normalizeString = (pkg) => {
      if (!pkg.name) {
        return removeBin(pkg);
      }
      pkg.bin = { [pkg.name]: pkg.bin };
      return normalizeObject(pkg);
    };
    var normalizeArray = (pkg) => {
      pkg.bin = pkg.bin.reduce((acc, k) => {
        acc[basename(k)] = k;
        return acc;
      }, {});
      return normalizeObject(pkg);
    };
    var removeBin = (pkg) => {
      delete pkg.bin;
      return pkg;
    };
    var normalizeObject = (pkg) => {
      const orig = pkg.bin;
      const clean = {};
      let hasBins = false;
      Object.keys(orig).forEach((binKey) => {
        const base = join("/", basename(binKey.replace(/\\|:/g, "/"))).slice(1);
        if (typeof orig[binKey] !== "string" || !base) {
          return;
        }
        const binTarget = join("/", orig[binKey]).replace(/\\/g, "/").slice(1);
        if (!binTarget) {
          return;
        }
        clean[base] = binTarget;
        hasBins = true;
      });
      if (hasBins) {
        pkg.bin = clean;
      } else {
        delete pkg.bin;
      }
      return pkg;
    };
    module2.exports = normalize;
  }
});
var require_lib2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/npm-bundled@2.0.1/node_modules/npm-bundled/lib/index.js"(exports, module2) {
    "use strict";
    var fs2 = (0, import_chunk_FVJ3R4NJ.__require)("fs");
    var path2 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    var EE = (0, import_chunk_FVJ3R4NJ.__require)("events").EventEmitter;
    var normalizePackageBin = require_lib();
    var BundleWalker = class _BundleWalker extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.path = path2.resolve(opt.path || process.cwd());
        this.parent = opt.parent || null;
        if (this.parent) {
          this.result = this.parent.result;
          if (!this.parent.parent) {
            const base = path2.basename(this.path);
            const scope = path2.basename(path2.dirname(this.path));
            this.result.add(/^@/.test(scope) ? scope + "/" + base : base);
          }
          this.root = this.parent.root;
          this.packageJsonCache = this.parent.packageJsonCache;
        } else {
          this.result = /* @__PURE__ */ new Set();
          this.root = this.path;
          this.packageJsonCache = opt.packageJsonCache || /* @__PURE__ */ new Map();
        }
        this.seen = /* @__PURE__ */ new Set();
        this.didDone = false;
        this.children = 0;
        this.node_modules = [];
        this.package = null;
        this.bundle = null;
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "done" && this.didDone) {
          this.emit("done", this.result);
        }
        return ret;
      }
      done() {
        if (!this.didDone) {
          this.didDone = true;
          if (!this.parent) {
            const res = Array.from(this.result);
            this.result = res;
            this.emit("done", res);
          } else {
            this.emit("done");
          }
        }
      }
      start() {
        const pj = path2.resolve(this.path, "package.json");
        if (this.packageJsonCache.has(pj)) {
          this.onPackage(this.packageJsonCache.get(pj));
        } else {
          this.readPackageJson(pj);
        }
        return this;
      }
      readPackageJson(pj) {
        fs2.readFile(pj, (er, data) => er ? this.done() : this.onPackageJson(pj, data));
      }
      onPackageJson(pj, data) {
        try {
          this.package = normalizePackageBin(JSON.parse(data + ""));
        } catch (er) {
          return this.done();
        }
        this.packageJsonCache.set(pj, this.package);
        this.onPackage(this.package);
      }
      allDepsBundled(pkg) {
        return Object.keys(pkg.dependencies || {}).concat(
          Object.keys(pkg.optionalDependencies || {})
        );
      }
      onPackage(pkg) {
        const bdRaw = this.parent ? this.allDepsBundled(pkg) : pkg.bundleDependencies || pkg.bundledDependencies || [];
        const bd = Array.from(new Set(
          Array.isArray(bdRaw) ? bdRaw : bdRaw === true ? this.allDepsBundled(pkg) : Object.keys(bdRaw)
        ));
        if (!bd.length) {
          return this.done();
        }
        this.bundle = bd;
        this.readModules();
      }
      readModules() {
        readdirNodeModules(this.path + "/node_modules", (er, nm) => er ? this.onReaddir([]) : this.onReaddir(nm));
      }
      onReaddir(nm) {
        this.node_modules = nm;
        this.bundle.forEach((dep) => this.childDep(dep));
        if (this.children === 0) {
          this.done();
        }
      }
      childDep(dep) {
        if (this.node_modules.indexOf(dep) !== -1) {
          if (!this.seen.has(dep)) {
            this.seen.add(dep);
            this.child(dep);
          }
        } else if (this.parent) {
          this.parent.childDep(dep);
        }
      }
      child(dep) {
        const p = this.path + "/node_modules/" + dep;
        this.children += 1;
        const child = new _BundleWalker({
          path: p,
          parent: this
        });
        child.on("done", (_) => {
          if (--this.children === 0) {
            this.done();
          }
        });
        child.start();
      }
    };
    var BundleWalkerSync = class _BundleWalkerSync extends BundleWalker {
      start() {
        super.start();
        this.done();
        return this;
      }
      readPackageJson(pj) {
        try {
          this.onPackageJson(pj, fs2.readFileSync(pj));
        } catch {
        }
        return this;
      }
      readModules() {
        try {
          this.onReaddir(readdirNodeModulesSync(this.path + "/node_modules"));
        } catch {
          this.onReaddir([]);
        }
      }
      child(dep) {
        new _BundleWalkerSync({
          path: this.path + "/node_modules/" + dep,
          parent: this
        }).start();
      }
    };
    var readdirNodeModules = (nm, cb) => {
      fs2.readdir(nm, (er, set) => {
        if (er) {
          cb(er);
        } else {
          const scopes = set.filter((f) => /^@/.test(f));
          if (!scopes.length) {
            cb(null, set);
          } else {
            const unscoped = set.filter((f) => !/^@/.test(f));
            let count = scopes.length;
            scopes.forEach((scope) => {
              fs2.readdir(nm + "/" + scope, (readdirEr, pkgs) => {
                if (readdirEr || !pkgs.length) {
                  unscoped.push(scope);
                } else {
                  unscoped.push.apply(unscoped, pkgs.map((p) => scope + "/" + p));
                }
                if (--count === 0) {
                  cb(null, unscoped);
                }
              });
            });
          }
        }
      });
    };
    var readdirNodeModulesSync = (nm) => {
      const set = fs2.readdirSync(nm);
      const unscoped = set.filter((f) => !/^@/.test(f));
      const scopes = set.filter((f) => /^@/.test(f)).map((scope) => {
        try {
          const pkgs = fs2.readdirSync(nm + "/" + scope);
          return pkgs.length ? pkgs.map((p) => scope + "/" + p) : [scope];
        } catch (er) {
          return [scope];
        }
      }).reduce((a, b) => a.concat(b), []);
      return unscoped.concat(scopes);
    };
    var walk = (options, callback) => {
      const p = new Promise((resolve, reject) => {
        new BundleWalker(options).on("done", resolve).on("error", reject).start();
      });
      return callback ? p.then((res) => callback(null, res), callback) : p;
    };
    var walkSync = (options) => {
      return new BundleWalkerSync(options).start().result;
    };
    module2.exports = walk;
    walk.sync = walkSync;
    walk.BundleWalker = BundleWalker;
    walk.BundleWalkerSync = BundleWalkerSync;
  }
});
var require_lib3 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/ignore-walk@5.0.1/node_modules/ignore-walk/lib/index.js"(exports, module2) {
    "use strict";
    var fs2 = (0, import_chunk_FVJ3R4NJ.__require)("fs");
    var path2 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    var EE = (0, import_chunk_FVJ3R4NJ.__require)("events").EventEmitter;
    var Minimatch = (0, import_chunk_UWXPWM6Q.require_minimatch)().Minimatch;
    var Walker = class _Walker extends EE {
      constructor(opts) {
        opts = opts || {};
        super(opts);
        this.isSymbolicLink = opts.isSymbolicLink;
        this.path = opts.path || process.cwd();
        this.basename = path2.basename(this.path);
        this.ignoreFiles = opts.ignoreFiles || [".ignore"];
        this.ignoreRules = {};
        this.parent = opts.parent || null;
        this.includeEmpty = !!opts.includeEmpty;
        this.root = this.parent ? this.parent.root : this.path;
        this.follow = !!opts.follow;
        this.result = this.parent ? this.parent.result : /* @__PURE__ */ new Set();
        this.entries = null;
        this.sawError = false;
      }
      sort(a, b) {
        return a.localeCompare(b, "en");
      }
      emit(ev, data) {
        let ret = false;
        if (!(this.sawError && ev === "error")) {
          if (ev === "error") {
            this.sawError = true;
          } else if (ev === "done" && !this.parent) {
            data = Array.from(data).map((e) => /^@/.test(e) ? `./${e}` : e).sort(this.sort);
            this.result = data;
          }
          if (ev === "error" && this.parent) {
            ret = this.parent.emit("error", data);
          } else {
            ret = super.emit(ev, data);
          }
        }
        return ret;
      }
      start() {
        fs2.readdir(this.path, (er, entries) => er ? this.emit("error", er) : this.onReaddir(entries));
        return this;
      }
      isIgnoreFile(e) {
        return e !== "." && e !== ".." && this.ignoreFiles.indexOf(e) !== -1;
      }
      onReaddir(entries) {
        this.entries = entries;
        if (entries.length === 0) {
          if (this.includeEmpty) {
            this.result.add(this.path.slice(this.root.length + 1));
          }
          this.emit("done", this.result);
        } else {
          const hasIg = this.entries.some((e) => this.isIgnoreFile(e));
          if (hasIg) {
            this.addIgnoreFiles();
          } else {
            this.filterEntries();
          }
        }
      }
      addIgnoreFiles() {
        const newIg = this.entries.filter((e) => this.isIgnoreFile(e));
        let igCount = newIg.length;
        const then = (_) => {
          if (--igCount === 0) {
            this.filterEntries();
          }
        };
        newIg.forEach((e) => this.addIgnoreFile(e, then));
      }
      addIgnoreFile(file, then) {
        const ig = path2.resolve(this.path, file);
        fs2.readFile(ig, "utf8", (er, data) => er ? this.emit("error", er) : this.onReadIgnoreFile(file, data, then));
      }
      onReadIgnoreFile(file, data, then) {
        const mmopt = {
          matchBase: true,
          dot: true,
          flipNegate: true,
          nocase: true
        };
        const rules = data.split(/\r?\n/).filter((line) => !/^#|^$/.test(line.trim())).map((rule) => {
          return new Minimatch(rule.trim(), mmopt);
        });
        this.ignoreRules[file] = rules;
        then();
      }
      filterEntries() {
        const filtered = this.entries.map((entry) => {
          const passFile = this.filterEntry(entry);
          const passDir = this.filterEntry(entry, true);
          return passFile || passDir ? [entry, passFile, passDir] : false;
        }).filter((e) => e);
        let entryCount = filtered.length;
        if (entryCount === 0) {
          this.emit("done", this.result);
        } else {
          const then = (_) => {
            if (--entryCount === 0) {
              this.emit("done", this.result);
            }
          };
          filtered.forEach((filt) => {
            const entry = filt[0];
            const file = filt[1];
            const dir = filt[2];
            this.stat({ entry, file, dir }, then);
          });
        }
      }
      onstat({ st, entry, file, dir, isSymbolicLink }, then) {
        const abs = this.path + "/" + entry;
        if (!st.isDirectory()) {
          if (file) {
            this.result.add(abs.slice(this.root.length + 1));
          }
          then();
        } else {
          if (dir) {
            this.walker(entry, { isSymbolicLink }, then);
          } else {
            then();
          }
        }
      }
      stat({ entry, file, dir }, then) {
        const abs = this.path + "/" + entry;
        fs2.lstat(abs, (lstatErr, lstatResult) => {
          if (lstatErr) {
            this.emit("error", lstatErr);
          } else {
            const isSymbolicLink = lstatResult.isSymbolicLink();
            if (this.follow && isSymbolicLink) {
              fs2.stat(abs, (statErr, statResult) => {
                if (statErr) {
                  this.emit("error", statErr);
                } else {
                  this.onstat({ st: statResult, entry, file, dir, isSymbolicLink }, then);
                }
              });
            } else {
              this.onstat({ st: lstatResult, entry, file, dir, isSymbolicLink }, then);
            }
          }
        });
      }
      walkerOpt(entry, opts) {
        return {
          path: this.path + "/" + entry,
          parent: this,
          ignoreFiles: this.ignoreFiles,
          follow: this.follow,
          includeEmpty: this.includeEmpty,
          ...opts
        };
      }
      walker(entry, opts, then) {
        new _Walker(this.walkerOpt(entry, opts)).on("done", then).start();
      }
      filterEntry(entry, partial) {
        let included = true;
        if (this.parent && this.parent.filterEntry) {
          var pt = this.basename + "/" + entry;
          included = this.parent.filterEntry(pt, partial);
        }
        this.ignoreFiles.forEach((f) => {
          if (this.ignoreRules[f]) {
            this.ignoreRules[f].forEach((rule) => {
              if (rule.negate !== included) {
                const match = rule.match("/" + entry) || rule.match(entry) || !!partial && (rule.match("/" + entry + "/") || rule.match(entry + "/")) || !!partial && rule.negate && (rule.match("/" + entry, true) || rule.match(entry, true));
                if (match) {
                  included = rule.negate;
                }
              }
            });
          }
        });
        return included;
      }
    };
    var WalkerSync = class _WalkerSync extends Walker {
      start() {
        this.onReaddir(fs2.readdirSync(this.path));
        return this;
      }
      addIgnoreFile(file, then) {
        const ig = path2.resolve(this.path, file);
        this.onReadIgnoreFile(file, fs2.readFileSync(ig, "utf8"), then);
      }
      stat({ entry, file, dir }, then) {
        const abs = this.path + "/" + entry;
        let st = fs2.lstatSync(abs);
        const isSymbolicLink = st.isSymbolicLink();
        if (this.follow && isSymbolicLink) {
          st = fs2.statSync(abs);
        }
        this.onstat({ st, entry, file, dir, isSymbolicLink }, then);
      }
      walker(entry, opts, then) {
        new _WalkerSync(this.walkerOpt(entry, opts)).start();
        then();
      }
    };
    var walk = (opts, callback) => {
      const p = new Promise((resolve, reject) => {
        new Walker(opts).on("done", resolve).on("error", reject).start();
      });
      return callback ? p.then((res) => callback(null, res), callback) : p;
    };
    var walkSync = (opts) => new WalkerSync(opts).start().result;
    module2.exports = walk;
    walk.sync = walkSync;
    walk.Walker = Walker;
    walk.WalkerSync = WalkerSync;
  }
});
var require_lib4 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/npm-packlist@5.1.3/node_modules/npm-packlist/lib/index.js"(exports, module2) {
    "use strict";
    var bundleWalk = require_lib2();
    var BundleWalker = bundleWalk.BundleWalker;
    var ignoreWalk = require_lib3();
    var IgnoreWalker = ignoreWalk.Walker;
    var rootBuiltinRules = Symbol("root-builtin-rules");
    var packageNecessaryRules = Symbol("package-necessary-rules");
    var path2 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    var normalizePackageBin = require_lib();
    var packageMustHaveFileNames = "readme|copying|license|licence";
    var packageMustHaves = `@(${packageMustHaveFileNames}){,.*[^~$]}`;
    var packageMustHavesRE = new RegExp(`^(${packageMustHaveFileNames})(\\..*[^~$])?$`, "i");
    var fs2 = (0, import_chunk_FVJ3R4NJ.__require)("fs");
    var glob = (0, import_chunk_UWXPWM6Q.require_glob)();
    var globify = (pattern) => pattern.split("\\").join("/");
    var readOutOfTreeIgnoreFiles = (root, rel, result = "") => {
      for (const file of [".npmignore", ".gitignore"]) {
        try {
          const ignoreContent = fs2.readFileSync(path2.join(root, file), { encoding: "utf8" });
          result += ignoreContent + "\n";
          break;
        } catch (err) {
          if (err.code !== "ENOENT") {
            throw err;
          }
        }
      }
      if (!rel) {
        return result;
      }
      const firstRel = rel.split(path2.sep)[0];
      const newRoot = path2.join(root, firstRel);
      const newRel = path2.relative(newRoot, path2.join(root, rel));
      return readOutOfTreeIgnoreFiles(newRoot, newRel, result);
    };
    var pathHasPkg = (input) => {
      if (!input.startsWith("node_modules/")) {
        return false;
      }
      const segments = input.slice("node_modules/".length).split("/", 2);
      return segments[0].startsWith("@") ? segments.length === 2 : true;
    };
    var pkgFromPath = (input) => {
      const segments = input.slice("node_modules/".length).split("/", 2);
      return segments[0].startsWith("@") ? segments.join("/") : segments[0];
    };
    var defaultRules = [
      ".npmignore",
      ".gitignore",
      "**/.git",
      "**/.svn",
      "**/.hg",
      "**/CVS",
      "**/.git/**",
      "**/.svn/**",
      "**/.hg/**",
      "**/CVS/**",
      "/.lock-wscript",
      "/.wafpickle-*",
      "/build/config.gypi",
      "npm-debug.log",
      "**/.npmrc",
      ".*.swp",
      ".DS_Store",
      "**/.DS_Store/**",
      "._*",
      "**/._*/**",
      "*.orig",
      "/package-lock.json",
      "/yarn.lock",
      "/pnpm-lock.yaml",
      "/archived-packages/**"
    ];
    var nameIsBadForWindows = (file) => /\*/.test(file);
    var Walker = class _Walker extends IgnoreWalker {
      constructor(opt) {
        opt = opt || {};
        opt.ignoreFiles = [
          rootBuiltinRules,
          "package.json",
          ".npmignore",
          ".gitignore",
          packageNecessaryRules
        ];
        opt.includeEmpty = false;
        opt.path = opt.path || process.cwd();
        const followRe = /^(?:\/node_modules\/(?:@[^/]+\/[^/]+|[^/]+)\/)*\/node_modules(?:\/@[^/]+)?$/;
        const rootPath = opt.parent ? opt.parent.root : opt.path;
        const followTestPath = opt.path.replace(/\\/g, "/").slice(rootPath.length);
        opt.follow = followRe.test(followTestPath);
        super(opt);
        if (this.isProject) {
          this.bundled = opt.bundled || [];
          this.bundledScopes = Array.from(new Set(
            this.bundled.filter((f) => /^@/.test(f)).map((f) => f.split("/")[0])
          ));
          this.packageJsonCache = this.parent ? this.parent.packageJsonCache : opt.packageJsonCache || /* @__PURE__ */ new Map();
          let rules = defaultRules.join("\n") + "\n";
          if (opt.prefix && opt.workspaces) {
            const gPath = globify(opt.path);
            const gPrefix = globify(opt.prefix);
            const gWorkspaces = opt.workspaces.map((ws) => globify(ws));
            if (gPath !== gPrefix && gWorkspaces.includes(gPath)) {
              const relpath = path2.relative(opt.prefix, path2.dirname(opt.path));
              rules += readOutOfTreeIgnoreFiles(opt.prefix, relpath);
            } else if (gPath === gPrefix) {
              rules += opt.workspaces.map((ws) => globify(path2.relative(opt.path, ws))).join("\n");
            }
          }
          super.onReadIgnoreFile(rootBuiltinRules, rules, (_) => _);
        } else {
          this.bundled = [];
          this.bundledScopes = [];
          this.packageJsonCache = this.parent.packageJsonCache;
        }
      }
      get isProject() {
        return !this.parent || this.parent.follow && this.isSymbolicLink;
      }
      onReaddir(entries) {
        if (this.isProject) {
          entries = entries.filter(
            (e) => e !== ".git" && !(e === "node_modules" && this.bundled.length === 0)
          );
        }
        if (!this.isProject || !entries.includes("package.json")) {
          return super.onReaddir(entries);
        }
        const ig = path2.resolve(this.path, "package.json");
        if (this.packageJsonCache.has(ig)) {
          const pkg = this.packageJsonCache.get(ig);
          if (!pkg || typeof pkg !== "object") {
            return this.readPackageJson(entries);
          }
          return this.getPackageFiles(entries, JSON.stringify(pkg));
        }
        this.readPackageJson(entries);
      }
      onReadPackageJson(entries, er, pkg) {
        if (er) {
          this.emit("error", er);
        } else {
          this.getPackageFiles(entries, pkg);
        }
      }
      mustHaveFilesFromPackage(pkg) {
        const files = [];
        if (pkg.browser) {
          files.push("/" + pkg.browser);
        }
        if (pkg.main) {
          files.push("/" + pkg.main);
        }
        if (pkg.bin) {
          for (const key in pkg.bin) {
            files.push("/" + pkg.bin[key]);
          }
        }
        files.push(
          "/package.json",
          "/npm-shrinkwrap.json",
          "!/package-lock.json",
          packageMustHaves
        );
        return files;
      }
      getPackageFiles(entries, pkg) {
        try {
          pkg = normalizePackageBin(JSON.parse(pkg.toString()));
        } catch (er) {
          return super.onReaddir(entries);
        }
        const ig = path2.resolve(this.path, "package.json");
        this.packageJsonCache.set(ig, pkg);
        if (!Array.isArray(pkg.files)) {
          return super.onReaddir(entries);
        }
        pkg.files.push(...this.mustHaveFilesFromPackage(pkg));
        if ((pkg.bundleDependencies || pkg.bundledDependencies) && entries.includes("node_modules")) {
          pkg.files.push("node_modules");
        }
        const patterns = Array.from(new Set(pkg.files)).reduce((set2, pattern) => {
          const excl = pattern.match(/^!+/);
          if (excl) {
            pattern = pattern.slice(excl[0].length);
          }
          pattern = pattern.replace(/^\.?\/+/, "");
          const negate = excl && excl[0].length % 2 === 1;
          set2.push({ pattern, negate });
          return set2;
        }, []);
        let n = patterns.length;
        const set = /* @__PURE__ */ new Set();
        const negates = /* @__PURE__ */ new Set();
        const results = [];
        const then = (pattern, negate, er, fileList, i) => {
          if (er) {
            return this.emit("error", er);
          }
          results[i] = { negate, fileList };
          if (--n === 0) {
            processResults(results);
          }
        };
        const processResults = (processed) => {
          for (const { negate, fileList } of processed) {
            if (negate) {
              fileList.forEach((f) => {
                f = f.replace(/\/+$/, "");
                set.delete(f);
                negates.add(f);
              });
            } else {
              fileList.forEach((f) => {
                f = f.replace(/\/+$/, "");
                set.add(f);
                negates.delete(f);
              });
            }
          }
          const list = Array.from(set);
          pkg.files = list.concat(Array.from(negates).map((f) => "!" + f));
          const rdResult = Array.from(new Set(
            list.map((f) => f.replace(/^\/+/, ""))
          ));
          super.onReaddir(rdResult);
        };
        patterns.forEach(({ pattern, negate }, i) => this.globFiles(pattern, (er, res) => then(pattern, negate, er, res, i)));
      }
      filterEntry(entry, partial) {
        const p = this.path.slice(this.root.length + 1);
        const { isProject } = this;
        const pkg = isProject && pathHasPkg(entry) ? pkgFromPath(entry) : null;
        const rootNM = isProject && entry === "node_modules";
        const rootPJ = isProject && entry === "package.json";
        return (
          // if we're in a bundled package, check with the parent.
          /^node_modules($|\/)/i.test(p) && !this.isProject ? this.parent.filterEntry(
            this.basename + "/" + entry,
            partial
          ) : pkg ? this.bundled.indexOf(pkg) !== -1 || this.bundledScopes.indexOf(pkg) !== -1 : rootNM ? !!this.bundled.length : rootPJ ? true : packageMustHavesRE.test(entry) ? true : isProject && (entry === "npm-shrinkwrap.json" || entry === "package.json") ? true : isProject && entry === "package-lock.json" ? false : super.filterEntry(entry, partial)
        );
      }
      filterEntries() {
        if (this.ignoreRules[".npmignore"]) {
          this.ignoreRules[".gitignore"] = null;
        }
        this.filterEntries = super.filterEntries;
        super.filterEntries();
      }
      addIgnoreFile(file, then) {
        const ig = path2.resolve(this.path, file);
        if (file === "package.json" && !this.isProject) {
          then();
        } else if (this.packageJsonCache.has(ig)) {
          this.onPackageJson(ig, this.packageJsonCache.get(ig), then);
        } else {
          super.addIgnoreFile(file, then);
        }
      }
      onPackageJson(ig, pkg, then) {
        this.packageJsonCache.set(ig, pkg);
        if (Array.isArray(pkg.files)) {
          super.onReadIgnoreFile("package.json", pkg.files.map(
            (f) => "!" + f
          ).join("\n") + "\n", then);
        } else {
          const rules = this.mustHaveFilesFromPackage(pkg).map((f) => `!${f}`);
          const data = rules.join("\n") + "\n";
          super.onReadIgnoreFile(packageNecessaryRules, data, then);
        }
      }
      // override parent stat function to completely skip any filenames
      // that will break windows entirely.
      // XXX(isaacs) Next major version should make this an error instead.
      stat({ entry, file, dir }, then) {
        if (nameIsBadForWindows(entry)) {
          then();
        } else {
          super.stat({ entry, file, dir }, then);
        }
      }
      // override parent onstat function to nix all symlinks, other than
      // those coming out of the followed bundled symlink deps
      onstat({ st, entry, file, dir, isSymbolicLink }, then) {
        if (st.isSymbolicLink()) {
          then();
        } else {
          super.onstat({ st, entry, file, dir, isSymbolicLink }, then);
        }
      }
      onReadIgnoreFile(file, data, then) {
        if (file === "package.json") {
          try {
            const ig = path2.resolve(this.path, file);
            this.onPackageJson(ig, JSON.parse(data), then);
          } catch (er) {
            then();
          }
        } else {
          super.onReadIgnoreFile(file, data, then);
        }
      }
      sort(a, b) {
        const exta = path2.extname(a).toLowerCase();
        const extb = path2.extname(b).toLowerCase();
        const basea = path2.basename(a).toLowerCase();
        const baseb = path2.basename(b).toLowerCase();
        return exta.localeCompare(extb, "en") || basea.localeCompare(baseb, "en") || a.localeCompare(b, "en");
      }
      globFiles(pattern, cb) {
        glob(globify(pattern), { dot: true, cwd: this.path, nocase: true }, cb);
      }
      readPackageJson(entries) {
        fs2.readFile(this.path + "/package.json", (er, pkg) => this.onReadPackageJson(entries, er, pkg));
      }
      walker(entry, opt, then) {
        new _Walker(this.walkerOpt(entry, opt)).on("done", then).start();
      }
    };
    var walk = (options, callback) => {
      options = options || {};
      const p = new Promise((resolve, reject) => {
        const bw = new BundleWalker(options);
        bw.on("done", (bundled) => {
          options.bundled = bundled;
          options.packageJsonCache = bw.packageJsonCache;
          new Walker(options).on("done", resolve).on("error", reject).start();
        });
        bw.start();
      });
      return callback ? p.then((res) => callback(null, res), callback) : p;
    };
    module2.exports = walk;
    walk.Walker = Walker;
  }
});
var require_crypto_random_string = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/crypto-random-string@2.0.0/node_modules/crypto-random-string/index.js"(exports, module2) {
    "use strict";
    var crypto = (0, import_chunk_FVJ3R4NJ.__require)("crypto");
    module2.exports = (length) => {
      if (!Number.isFinite(length)) {
        throw new TypeError("Expected a finite number");
      }
      return crypto.randomBytes(Math.ceil(length / 2)).toString("hex").slice(0, length);
    };
  }
});
var require_unique_string = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/unique-string@2.0.0/node_modules/unique-string/index.js"(exports, module2) {
    "use strict";
    var cryptoRandomString = require_crypto_random_string();
    module2.exports = () => cryptoRandomString(32);
  }
});
var require_is_path_cwd = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/is-path-cwd@2.2.0/node_modules/is-path-cwd/index.js"(exports, module2) {
    "use strict";
    var path2 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    module2.exports = (path_) => {
      let cwd = process.cwd();
      path_ = path2.resolve(path_);
      if (process.platform === "win32") {
        cwd = cwd.toLowerCase();
        path_ = path_.toLowerCase();
      }
      return path_ === cwd;
    };
  }
});
var require_is_path_inside = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/is-path-inside@3.0.3/node_modules/is-path-inside/index.js"(exports, module2) {
    "use strict";
    var path2 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    module2.exports = (childPath, parentPath) => {
      const relation = path2.relative(parentPath, childPath);
      return Boolean(
        relation && relation !== ".." && !relation.startsWith(`..${path2.sep}`) && relation !== path2.resolve(childPath)
      );
    };
  }
});
var require_concat_map = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});
var require_brace_expansion = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js"(exports, module2) {
    "use strict";
    var concatMap = require_concat_map();
    var balanced = (0, import_chunk_UWXPWM6Q.require_balanced_match)();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});
var require_minimatch2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js"(exports, module2) {
    "use strict";
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path2 = function() {
      try {
        return (0, import_chunk_FVJ3R4NJ.__require)("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path2.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path2.sep !== "/") {
        pattern = pattern.split(path2.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path2.sep !== "/") {
        f = f.split(path2.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});
var require_path_is_absolute = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/path-is-absolute@1.0.1/node_modules/path-is-absolute/index.js"(exports, module2) {
    "use strict";
    function posix(path2) {
      return path2.charAt(0) === "/";
    }
    function win32(path2) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path2);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});
var require_common = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/common.js"(exports) {
    "use strict";
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs2 = (0, import_chunk_FVJ3R4NJ.__require)("fs");
    var path2 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    var minimatch = require_minimatch2();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self, options) {
      self.ignore = options.ignore || [];
      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore];
      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self.silent = !!options.silent;
      self.pattern = pattern;
      self.strict = options.strict !== false;
      self.realpath = !!options.realpath;
      self.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self.follow = !!options.follow;
      self.dot = !!options.dot;
      self.mark = !!options.mark;
      self.nodir = !!options.nodir;
      if (self.nodir)
        self.mark = true;
      self.sync = !!options.sync;
      self.nounique = !!options.nounique;
      self.nonull = !!options.nonull;
      self.nosort = !!options.nosort;
      self.nocase = !!options.nocase;
      self.stat = !!options.stat;
      self.noprocess = !!options.noprocess;
      self.absolute = !!options.absolute;
      self.fs = options.fs || fs2;
      self.maxLength = options.maxLength || Infinity;
      self.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self, options);
      self.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self.cwd = cwd;
      else {
        self.cwd = path2.resolve(options.cwd);
        self.changedCwd = self.cwd !== cwd;
      }
      self.root = options.root || path2.resolve(self.cwd, "/");
      self.root = path2.resolve(self.root);
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/");
      self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
      if (process.platform === "win32")
        self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
      self.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      options.allowWindowsEscape = false;
      self.minimatch = new Minimatch(pattern, options);
      self.options = self.minimatch.options;
    }
    function finish(self) {
      var nou = self.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self.matches.length; i < l; i++) {
        var matches = self.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            var literal = self.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self.nosort)
        all = all.sort(alphasort);
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i]);
        }
        if (self.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self.cache[e] || self.cache[makeAbs(self, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self, m2);
        });
      self.found = all;
    }
    function mark(self, p) {
      var abs = makeAbs(self, p);
      var c = self.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self, m);
          self.statCache[mabs] = self.statCache[abs];
          self.cache[mabs] = self.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path2.join(self.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self.changedCwd) {
        abs = path2.resolve(self.cwd, f);
      } else {
        abs = path2.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self, path3) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return item.matcher.match(path3) || !!(item.gmatcher && item.gmatcher.match(path3));
      });
    }
    function childrenIgnored(self, path3) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path3));
      });
    }
  }
});
var require_sync = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/sync.js"(exports, module2) {
    "use strict";
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = (0, import_chunk_UWXPWM6Q.require_fs)();
    var minimatch = require_minimatch2();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob2().Glob;
    var util = (0, import_chunk_FVJ3R4NJ.__require)("util");
    var path2 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    var assert = (0, import_chunk_FVJ3R4NJ.__require)("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self = this;
        this.matches.forEach(function(matchset, index) {
          var set = self.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self._makeAbs(p);
              var real = rp.realpathSync(p, self.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path2.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path2.join(this.root, prefix);
        } else {
          prefix = path2.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});
var require_glob2 = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/glob.js"(exports, module2) {
    "use strict";
    module2.exports = glob;
    var rp = (0, import_chunk_UWXPWM6Q.require_fs)();
    var minimatch = require_minimatch2();
    var Minimatch = minimatch.Minimatch;
    var inherits = (0, import_chunk_UWXPWM6Q.require_inherits)();
    var EE = (0, import_chunk_FVJ3R4NJ.__require)("events").EventEmitter;
    var path2 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    var assert = (0, import_chunk_FVJ3R4NJ.__require)("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = (0, import_chunk_UWXPWM6Q.require_inflight)();
    var util = (0, import_chunk_FVJ3R4NJ.__require)("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = (0, import_chunk_UWXPWM6Q.require_once)();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self._processing;
        if (self._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self._finish();
            });
          } else {
            self._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self._makeAbs(p);
        rp.realpath(p, self.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self.emit("error", er);
          if (--n === 0) {
            self.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path2.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self.cache[abs] = "FILE";
          cb();
        } else
          self._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self = this;
      self.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self, abs, cb) {
      return function(er, entries) {
        if (er)
          self._readdirError(abs, er, cb);
        else
          self._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self = this;
      this._stat(prefix, function(er, exists) {
        self._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path2.join(this.root, prefix);
        } else {
          prefix = path2.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self._stat2(f, abs, null, lstat, cb);
            else
              self._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});
var require_rimraf = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/rimraf@3.0.2/node_modules/rimraf/rimraf.js"(exports, module2) {
    "use strict";
    var assert = (0, import_chunk_FVJ3R4NJ.__require)("assert");
    var path2 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    var fs2 = (0, import_chunk_FVJ3R4NJ.__require)("fs");
    var glob = void 0;
    try {
      glob = require_glob2();
    } catch (_err) {
    }
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    var defaults = (options) => {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs2[m];
        m = m + "Sync";
        options[m] = options[m] || fs2[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    };
    var rimraf = (p, options, cb) => {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      let busyTries = 0;
      let errState = null;
      let n = 0;
      const next = (er) => {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      };
      const afterGlob = (er, results) => {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach((p2) => {
          const CB = (er2) => {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(() => rimraf_(p2, options, CB), timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          };
          rimraf_(p2, options, CB);
        });
      };
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, (er, stat) => {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
    };
    var rimraf_ = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    };
    var fixWinEPERM = (p, options, er, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, (er3, stats) => {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    };
    var fixWinEPERMSync = (p, options, er) => {
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      let stats;
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    };
    var rmdir = (p, options, originalEr, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    };
    var rmkids = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        let errState;
        files.forEach((f) => {
          rimraf(path2.join(p, f), options, (er2) => {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    };
    var rimrafSync = (p, options) => {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      let results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (let i = 0; i < results.length; i++) {
        const p2 = results[i];
        let st;
        try {
          st = options.lstatSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p2, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p2, options, null);
          else
            options.unlinkSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p2, options, er);
        }
      }
    };
    var rmdirSync = (p, options, originalEr) => {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    };
    var rmkidsSync = (p, options) => {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path2.join(p, f), options));
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    };
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});
var require_clean_stack = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/clean-stack@2.2.0/node_modules/clean-stack/index.js"(exports, module2) {
    "use strict";
    var os = (0, import_chunk_FVJ3R4NJ.__require)("os");
    var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
    var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
    var homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
    module2.exports = (stack, options) => {
      options = Object.assign({ pretty: false }, options);
      return stack.replace(/\\/g, "/").split("\n").filter((line) => {
        const pathMatches = line.match(extractPathRegex);
        if (pathMatches === null || !pathMatches[1]) {
          return true;
        }
        const match = pathMatches[1];
        if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
          return false;
        }
        return !pathRegex.test(match);
      }).filter((line) => line.trim() !== "").map((line) => {
        if (options.pretty) {
          return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")));
        }
        return line;
      }).join("\n");
    };
  }
});
var require_aggregate_error = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/aggregate-error@3.1.0/node_modules/aggregate-error/index.js"(exports, module2) {
    "use strict";
    var indentString = (0, import_chunk_ENSUX2GR.require_indent_string)();
    var cleanStack = require_clean_stack();
    var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        errors = [...errors].map((error) => {
          if (error instanceof Error) {
            return error;
          }
          if (error !== null && typeof error === "object") {
            return Object.assign(new Error(error.message), error);
          }
          return new Error(error);
        });
        let message = errors.map((error) => {
          return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
        }).join("\n");
        message = "\n" + indentString(message, 4);
        super(message);
        this.name = "AggregateError";
        Object.defineProperty(this, "_errors", { value: errors });
      }
      *[Symbol.iterator]() {
        for (const error of this._errors) {
          yield error;
        }
      }
    };
    module2.exports = AggregateError;
  }
});
var require_p_map = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/p-map@4.0.0/node_modules/p-map/index.js"(exports, module2) {
    "use strict";
    var AggregateError = require_aggregate_error();
    module2.exports = async (iterable, mapper, {
      concurrency = Infinity,
      stopOnError = true
    } = {}) => {
      return new Promise((resolve, reject) => {
        if (typeof mapper !== "function") {
          throw new TypeError("Mapper function is required");
        }
        if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
        }
        const result = [];
        const errors = [];
        const iterator = iterable[Symbol.iterator]();
        let isRejected = false;
        let isIterableDone = false;
        let resolvingCount = 0;
        let currentIndex = 0;
        const next = () => {
          if (isRejected) {
            return;
          }
          const nextItem = iterator.next();
          const index = currentIndex;
          currentIndex++;
          if (nextItem.done) {
            isIterableDone = true;
            if (resolvingCount === 0) {
              if (!stopOnError && errors.length !== 0) {
                reject(new AggregateError(errors));
              } else {
                resolve(result);
              }
            }
            return;
          }
          resolvingCount++;
          (async () => {
            try {
              const element = await nextItem.value;
              result[index] = await mapper(element, index);
              resolvingCount--;
              next();
            } catch (error) {
              if (stopOnError) {
                isRejected = true;
                reject(error);
              } else {
                errors.push(error);
                resolvingCount--;
                next();
              }
            }
          })();
        };
        for (let i = 0; i < concurrency; i++) {
          next();
          if (isIterableDone) {
            break;
          }
        }
      });
    };
  }
});
var require_del = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/del@6.1.1/node_modules/del/index.js"(exports, module2) {
    "use strict";
    var { promisify } = (0, import_chunk_FVJ3R4NJ.__require)("util");
    var path2 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    var globby = (0, import_chunk_PN7UG7JB.require_globby)();
    var isGlob = (0, import_chunk_PN7UG7JB.require_is_glob)();
    var slash = (0, import_chunk_PN7UG7JB.require_slash)();
    var gracefulFs = (0, import_chunk_JD7BZWTA.require_graceful_fs)();
    var isPathCwd = require_is_path_cwd();
    var isPathInside = require_is_path_inside();
    var rimraf = require_rimraf();
    var pMap = require_p_map();
    var rimrafP = promisify(rimraf);
    var rimrafOptions = {
      glob: false,
      unlink: gracefulFs.unlink,
      unlinkSync: gracefulFs.unlinkSync,
      chmod: gracefulFs.chmod,
      chmodSync: gracefulFs.chmodSync,
      stat: gracefulFs.stat,
      statSync: gracefulFs.statSync,
      lstat: gracefulFs.lstat,
      lstatSync: gracefulFs.lstatSync,
      rmdir: gracefulFs.rmdir,
      rmdirSync: gracefulFs.rmdirSync,
      readdir: gracefulFs.readdir,
      readdirSync: gracefulFs.readdirSync
    };
    function safeCheck(file, cwd) {
      if (isPathCwd(file)) {
        throw new Error("Cannot delete the current working directory. Can be overridden with the `force` option.");
      }
      if (!isPathInside(file, cwd)) {
        throw new Error("Cannot delete files/directories outside the current working directory. Can be overridden with the `force` option.");
      }
    }
    function normalizePatterns(patterns) {
      patterns = Array.isArray(patterns) ? patterns : [patterns];
      patterns = patterns.map((pattern) => {
        if (process.platform === "win32" && isGlob(pattern) === false) {
          return slash(pattern);
        }
        return pattern;
      });
      return patterns;
    }
    module2.exports = async (patterns, { force, dryRun, cwd = process.cwd(), onProgress = () => {
    }, ...options } = {}) => {
      options = {
        expandDirectories: false,
        onlyFiles: false,
        followSymbolicLinks: false,
        cwd,
        ...options
      };
      patterns = normalizePatterns(patterns);
      const files = (await globby(patterns, options)).sort((a, b) => b.localeCompare(a));
      if (files.length === 0) {
        onProgress({
          totalCount: 0,
          deletedCount: 0,
          percent: 1
        });
      }
      let deletedCount = 0;
      const mapper = async (file) => {
        file = path2.resolve(cwd, file);
        if (!force) {
          safeCheck(file, cwd);
        }
        if (!dryRun) {
          await rimrafP(file, rimrafOptions);
        }
        deletedCount += 1;
        onProgress({
          totalCount: files.length,
          deletedCount,
          percent: deletedCount / files.length
        });
        return file;
      };
      const removedFiles = await pMap(files, mapper, options);
      removedFiles.sort((a, b) => a.localeCompare(b));
      return removedFiles;
    };
    module2.exports.sync = (patterns, { force, dryRun, cwd = process.cwd(), ...options } = {}) => {
      options = {
        expandDirectories: false,
        onlyFiles: false,
        followSymbolicLinks: false,
        cwd,
        ...options
      };
      patterns = normalizePatterns(patterns);
      const files = globby.sync(patterns, options).sort((a, b) => b.localeCompare(a));
      const removedFiles = files.map((file) => {
        file = path2.resolve(cwd, file);
        if (!force) {
          safeCheck(file, cwd);
        }
        if (!dryRun) {
          rimraf.sync(file, rimrafOptions);
        }
        return file;
      });
      removedFiles.sort((a, b) => a.localeCompare(b));
      return removedFiles;
    };
  }
});
var require_tempy = (0, import_chunk_FVJ3R4NJ.__commonJS)({
  "../../node_modules/.pnpm/tempy@1.0.1/node_modules/tempy/index.js"(exports, module2) {
    "use strict";
    var fs2 = (0, import_chunk_FVJ3R4NJ.__require)("fs");
    var path2 = (0, import_chunk_FVJ3R4NJ.__require)("path");
    var uniqueString = require_unique_string();
    var tempDir = (0, import_chunk_G3BTRIWS.require_temp_dir)();
    var isStream = (0, import_chunk_RXZEDVTJ.require_is_stream)();
    var del = require_del();
    var stream = (0, import_chunk_FVJ3R4NJ.__require)("stream");
    var { promisify } = (0, import_chunk_FVJ3R4NJ.__require)("util");
    var pipeline = promisify(stream.pipeline);
    var { writeFile } = fs2.promises;
    var getPath = (prefix = "") => path2.join(tempDir, prefix + uniqueString());
    var writeStream = async (filePath, data) => pipeline(data, fs2.createWriteStream(filePath));
    var createTask = (tempyFunction, { extraArguments = 0 } = {}) => async (...arguments_) => {
      const [callback, options] = arguments_.slice(extraArguments);
      const result = await tempyFunction(...arguments_.slice(0, extraArguments), options);
      try {
        return await callback(result);
      } finally {
        await del(result, { force: true });
      }
    };
    module2.exports.file = (options) => {
      options = {
        ...options
      };
      if (options.name) {
        if (options.extension !== void 0 && options.extension !== null) {
          throw new Error("The `name` and `extension` options are mutually exclusive");
        }
        return path2.join(module2.exports.directory(), options.name);
      }
      return getPath() + (options.extension === void 0 || options.extension === null ? "" : "." + options.extension.replace(/^\./, ""));
    };
    module2.exports.file.task = createTask(module2.exports.file);
    module2.exports.directory = ({ prefix = "" } = {}) => {
      const directory = getPath(prefix);
      fs2.mkdirSync(directory);
      return directory;
    };
    module2.exports.directory.task = createTask(module2.exports.directory);
    module2.exports.write = async (data, options) => {
      const filename = module2.exports.file(options);
      const write = isStream(data) ? writeStream : writeFile;
      await write(filename, data);
      return filename;
    };
    module2.exports.write.task = createTask(module2.exports.write, { extraArguments: 1 });
    module2.exports.writeSync = (data, options) => {
      const filename = module2.exports.file(options);
      fs2.writeFileSync(filename, data);
      return filename;
    };
    Object.defineProperty(module2.exports, "root", {
      get() {
        return tempDir;
      }
    });
  }
});
var import_npm_packlist = (0, import_chunk_FVJ3R4NJ.__toESM)(require_lib4());
var import_tempy = (0, import_chunk_FVJ3R4NJ.__toESM)(require_tempy());
async function getPackedPackage(name, target, packageDir) {
  packageDir = packageDir || await (0, import_chunk_WIPBZJFE.resolvePkg)(name, { basedir: process.cwd() }) || await (0, import_chunk_WIPBZJFE.resolvePkg)(name, { basedir: target });
  if (!packageDir) {
    const pkg = (0, import_chunk_KXIPL557.readPackageUpSync)({
      cwd: target,
      normalize: false
    });
    if (pkg && pkg.packageJson.name === name) {
      packageDir = import_path.default.dirname(pkg.path);
    }
  }
  if (!packageDir && import_fs.default.existsSync(import_path.default.join(process.cwd(), "package.json"))) {
    packageDir = process.cwd();
  }
  if (!packageDir) {
    throw new Error(`Error in getPackage: Could not resolve package ${name} from ${process.cwd()} target ${target}`);
  }
  const tmpDir = target ?? import_tempy.default.directory();
  const pkgFiles = await (0, import_npm_packlist.default)({ path: packageDir });
  for (const file of pkgFiles) {
    const src = import_path.default.join(packageDir, file);
    const dest = import_path.default.join(tmpDir, file);
    await import_fs.default.promises.mkdir(import_path.default.dirname(dest), { recursive: true });
    await import_fs.default.promises.copyFile(src, dest);
  }
  return import_path.default.join(tmpDir);
}
