import type { WithPolicyOptions } from '.';
import { type ModelMeta } from '../../cross';
import { AuthUser, DbClientContract } from '../../types';
import { PrismaProxyHandler } from '../proxy';
import type { PolicyDef, ZodSchemas } from '../types';
/**
 * Prisma proxy handler for injecting access policy check.
 */
export declare class PolicyProxyHandler<DbClient extends DbClientContract> implements PrismaProxyHandler {
    private readonly prisma;
    private readonly policy;
    private readonly modelMeta;
    private readonly zodSchemas;
    private readonly user;
    private readonly options;
    private readonly logger;
    private readonly utils;
    private readonly model;
    private readonly DEFAULT_TX_MAXWAIT;
    private readonly DEFAULT_TX_TIMEOUT;
    constructor(prisma: DbClient, policy: PolicyDef, modelMeta: ModelMeta, zodSchemas: ZodSchemas | undefined, model: string, user: AuthUser | undefined, options: WithPolicyOptions | undefined);
    private get modelClient();
    findUnique(args: any): Promise<unknown>;
    findUniqueOrThrow(args: any): Promise<unknown>;
    findFirst(args?: any): Promise<unknown>;
    findFirstOrThrow(args: any): Promise<unknown>;
    findMany(args?: any): Promise<unknown[]>;
    private findWithFluentCallStubs;
    private doFind;
    private fluentCall;
    private addFluentFunctions;
    create(args: any): Promise<any>;
    private doCreate;
    private hasNestedCreateOrConnect;
    private validateCreateInputSchema;
    createMany(args: {
        data: any;
        skipDuplicates?: boolean;
    }): Promise<any>;
    private doCreateMany;
    private hasDuplicatedUniqueConstraint;
    update(args: any): Promise<any>;
    private doUpdate;
    private validateUpdateInputSchema;
    private isUnsafeMutate;
    private isAutoIncrementIdField;
    updateMany(args: any): Promise<any>;
    upsert(args: any): Promise<any>;
    delete(args: any): Promise<any>;
    deleteMany(args: any): Promise<{
        count: number;
    }>;
    aggregate(args: any): Promise<any>;
    groupBy(args: any): Promise<any>;
    count(args: any): Promise<any>;
    subscribe(args: any): Promise<any>;
    private get shouldLogQuery();
    private transaction;
    private runPostWriteChecks;
    private makeHandler;
    private requireBackLink;
    private mergeToParent;
    private removeFromParent;
}
