"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
const ast_1 = require("@zenstackhq/language/ast");
const lower_case_first_1 = require("lower-case-first");
const ts_morph_1 = require("ts-morph");
const _1 = require(".");
function generate(project, models, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const sf = project.createSourceFile(options.output, undefined, { overwrite: true });
        sf.addStatements('/* eslint-disable */');
        sf.addVariableStatement({
            declarationKind: ts_morph_1.VariableDeclarationKind.Const,
            declarations: [{ name: 'metadata', initializer: (writer) => generateModelMetadata(models, writer, options) }],
        });
        sf.addStatements('export default metadata;');
        if (!options.compile || options.preserveTsFiles) {
            // save ts files
            yield (0, _1.saveProject)(project);
        }
        if (options.compile) {
            yield (0, _1.emitProject)(project);
        }
    });
}
exports.generate = generate;
function generateModelMetadata(dataModels, writer, options) {
    writer.block(() => {
        writer.write('fields:');
        writer.block(() => {
            for (const model of dataModels) {
                writer.write(`${(0, lower_case_first_1.lowerCaseFirst)(model.name)}:`);
                writer.block(() => {
                    var _a;
                    for (const f of model.fields) {
                        const backlink = getBackLink(f);
                        const fkMapping = generateForeignKeyMapping(f);
                        writer.write(`${f.name}: {
                    name: "${f.name}",
                    type: "${f.type.reference
                            ? f.type.reference.$refText
                            : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                f.type.type}",`);
                        if ((0, _1.isIdField)(f)) {
                            writer.write(`
                    isId: true,`);
                        }
                        if ((0, ast_1.isDataModel)((_a = f.type.reference) === null || _a === void 0 ? void 0 : _a.ref)) {
                            writer.write(`
                    isDataModel: true,`);
                        }
                        if (f.type.array) {
                            writer.write(`
                    isArray: true,`);
                        }
                        if (f.type.optional) {
                            writer.write(`
                    isOptional: true,`);
                        }
                        if (options.generateAttributes) {
                            const attrs = getFieldAttributes(f);
                            if (attrs.length > 0) {
                                writer.write(`
                    attributes: ${JSON.stringify(attrs)},`);
                            }
                        }
                        else {
                            // only include essential attributes
                            const attrs = getFieldAttributes(f).filter((attr) => ['@default', '@updatedAt'].includes(attr.name));
                            if (attrs.length > 0) {
                                writer.write(`
                    attributes: ${JSON.stringify(attrs)},`);
                            }
                        }
                        if (backlink) {
                            writer.write(`
                    backLink: '${backlink.name}',`);
                        }
                        if (isRelationOwner(f, backlink)) {
                            writer.write(`
                    isRelationOwner: true,`);
                        }
                        if ((0, _1.isForeignKeyField)(f)) {
                            writer.write(`
                    isForeignKey: true,`);
                        }
                        if (fkMapping && Object.keys(fkMapping).length > 0) {
                            writer.write(`
                    foreignKeyMapping: ${JSON.stringify(fkMapping)},`);
                        }
                        if (isAutoIncrement(f)) {
                            writer.write(`
                    isAutoIncrement: true,`);
                        }
                        writer.write(`
                },`);
                    }
                });
                writer.write(',');
            }
        });
        writer.write(',');
        writer.write('uniqueConstraints:');
        writer.block(() => {
            for (const model of dataModels) {
                writer.write(`${(0, lower_case_first_1.lowerCaseFirst)(model.name)}:`);
                writer.block(() => {
                    for (const constraint of getUniqueConstraints(model)) {
                        writer.write(`${constraint.name}: {
                    name: "${constraint.name}",
                    fields: ${JSON.stringify(constraint.fields)}
                },`);
                    }
                });
                writer.write(',');
            }
        });
        writer.write(',');
        writer.write('deleteCascade:');
        writer.block(() => {
            for (const model of dataModels) {
                const cascades = getDeleteCascades(model);
                if (cascades.length > 0) {
                    writer.writeLine(`${(0, lower_case_first_1.lowerCaseFirst)(model.name)}: [${cascades.map((n) => `'${n}'`).join(', ')}],`);
                }
            }
        });
        writer.write(',');
        const authModel = (0, _1.getAuthModel)(dataModels);
        if (authModel) {
            writer.writeLine(`authModel: '${authModel.name}'`);
        }
    });
}
function getBackLink(field) {
    var _a, _b, _c;
    if (!((_a = field.type.reference) === null || _a === void 0 ? void 0 : _a.ref) || !(0, ast_1.isDataModel)((_b = field.type.reference) === null || _b === void 0 ? void 0 : _b.ref)) {
        return undefined;
    }
    const relName = getRelationName(field);
    const sourceModel = field.$container;
    const targetModel = field.type.reference.ref;
    for (const otherField of targetModel.fields) {
        if (((_c = otherField.type.reference) === null || _c === void 0 ? void 0 : _c.ref) === sourceModel) {
            if (relName) {
                const otherRelName = getRelationName(otherField);
                if (relName === otherRelName) {
                    return otherField;
                }
            }
            else {
                return otherField;
            }
        }
    }
    return undefined;
}
function getRelationName(field) {
    var _a, _b;
    const relAttr = field.attributes.find((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@relation'; });
    const relName = relAttr && ((_a = relAttr.args) === null || _a === void 0 ? void 0 : _a[0]) && (0, _1.getLiteral)((_b = relAttr.args) === null || _b === void 0 ? void 0 : _b[0].value);
    return relName;
}
function getFieldAttributes(field) {
    return field.attributes
        .map((attr) => {
        const args = [];
        for (const arg of attr.args) {
            if ((0, ast_1.isNumberLiteral)(arg.value)) {
                let v = parseInt(arg.value.value);
                if (isNaN(v)) {
                    v = parseFloat(arg.value.value);
                }
                if (isNaN(v)) {
                    throw new Error(`Invalid number literal: ${arg.value.value}`);
                }
                args.push({ name: arg.name, value: v });
            }
            else if ((0, ast_1.isStringLiteral)(arg.value) || (0, ast_1.isBooleanLiteral)(arg.value)) {
                args.push({ name: arg.name, value: arg.value.value });
            }
            else {
                // non-literal args are ignored
            }
        }
        return { name: (0, _1.resolved)(attr.decl).name, args };
    })
        .filter((d) => !!d);
}
function getUniqueConstraints(model) {
    const constraints = [];
    // model-level constraints
    for (const attr of model.attributes.filter((attr) => { var _a, _b; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@@unique' || ((_b = attr.decl.ref) === null || _b === void 0 ? void 0 : _b.name) === '@@id'; })) {
        const argsMap = (0, _1.getAttributeArgs)(attr);
        if (argsMap.fields) {
            const fieldNames = argsMap.fields.items.map((item) => (0, _1.resolved)(item.target).name);
            let constraintName = argsMap.name && (0, _1.getLiteral)(argsMap.name);
            if (!constraintName) {
                // default constraint name is fields concatenated with underscores
                constraintName = fieldNames.join('_');
            }
            constraints.push({ name: constraintName, fields: fieldNames });
        }
    }
    // field-level constraints
    for (const field of model.fields) {
        if ((0, _1.hasAttribute)(field, '@id') || (0, _1.hasAttribute)(field, '@unique')) {
            constraints.push({ name: field.name, fields: [field.name] });
        }
    }
    return constraints;
}
function isRelationOwner(field, backLink) {
    var _a;
    if (!(0, ast_1.isDataModel)((_a = field.type.reference) === null || _a === void 0 ? void 0 : _a.ref)) {
        return false;
    }
    if (!backLink) {
        // CHECKME: can this really happen?
        return true;
    }
    if (!(0, _1.hasAttribute)(field, '@relation') && !(0, _1.hasAttribute)(backLink, '@relation')) {
        // if neither side has `@relation` attribute, it's an implicit many-to-many relation,
        // both sides are owners
        return true;
    }
    return holdsForeignKey(field);
}
function holdsForeignKey(field) {
    const relation = field.attributes.find((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@relation'; });
    if (!relation) {
        return false;
    }
    const fields = (0, _1.getAttributeArg)(relation, 'fields');
    return !!fields;
}
function generateForeignKeyMapping(field) {
    const relation = field.attributes.find((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@relation'; });
    if (!relation) {
        return undefined;
    }
    const fields = (0, _1.getAttributeArg)(relation, 'fields');
    const references = (0, _1.getAttributeArg)(relation, 'references');
    if (!(0, ast_1.isArrayExpr)(fields) || !(0, ast_1.isArrayExpr)(references) || fields.items.length !== references.items.length) {
        return undefined;
    }
    const fieldNames = fields.items.map((item) => ((0, ast_1.isReferenceExpr)(item) ? item.target.$refText : undefined));
    const referenceNames = references.items.map((item) => ((0, ast_1.isReferenceExpr)(item) ? item.target.$refText : undefined));
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const result = {};
    referenceNames.forEach((name, i) => {
        if (name) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            result[name] = fieldNames[i];
        }
    });
    return result;
}
function getDeleteCascades(model) {
    const allModels = (0, _1.getDataModels)(model.$container);
    return allModels
        .filter((m) => {
        if (m === model) {
            return false;
        }
        const relationFields = m.fields.filter((f) => {
            var _a, _b;
            if (((_a = f.type.reference) === null || _a === void 0 ? void 0 : _a.ref) !== model) {
                return false;
            }
            const relationAttr = (0, _1.getAttribute)(f, '@relation');
            if (relationAttr) {
                const onDelete = (0, _1.getAttributeArg)(relationAttr, 'onDelete');
                if (onDelete && (0, _1.isEnumFieldReference)(onDelete) && ((_b = onDelete.target.ref) === null || _b === void 0 ? void 0 : _b.name) === 'Cascade') {
                    return true;
                }
            }
            return false;
        });
        return relationFields.length > 0;
    })
        .map((m) => m.name);
}
function isAutoIncrement(field) {
    var _a;
    const defaultAttr = (0, _1.getAttribute)(field, '@default');
    if (!defaultAttr) {
        return false;
    }
    const arg = (_a = defaultAttr.args[0]) === null || _a === void 0 ? void 0 : _a.value;
    if (!arg) {
        return false;
    }
    return (0, ast_1.isInvocationExpr)(arg) && arg.function.$refText === 'autoincrement';
}
//# sourceMappingURL=model-meta-generator.js.map