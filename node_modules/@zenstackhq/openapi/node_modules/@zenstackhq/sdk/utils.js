"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAuthModel = exports.getPreviewFeatures = exports.getContainingModel = exports.isFromStdlib = exports.isFutureExpr = exports.getFunctionExpressionContext = exports.parseOptionAsStrings = exports.requireOption = exports.resolvePath = exports.isForeignKeyField = exports.isRelationshipField = exports.isIdField = exports.getModelUniqueFields = exports.getModelIdFields = exports.isDataModelFieldReference = exports.isEnumFieldReference = exports.getAttributeArgLiteral = exports.getAttributeArg = exports.getAttributeArgs = exports.getAttribute = exports.hasAttribute = exports.indentString = exports.getObjectLiteral = exports.getLiteralArray = exports.getArray = exports.getLiteral = exports.resolved = exports.getDataModels = void 0;
const ast_1 = require("@zenstackhq/language/ast");
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const types_1 = require("./types");
/**
 * Gets data models that are not ignored
 */
function getDataModels(model, includeIgnored = false) {
    const r = model.declarations.filter((d) => (0, ast_1.isDataModel)(d));
    if (includeIgnored) {
        return r;
    }
    else {
        return r.filter((model) => !hasAttribute(model, '@@ignore'));
    }
}
exports.getDataModels = getDataModels;
function resolved(ref) {
    if (!ref.ref) {
        throw new Error(`Reference not resolved: ${ref.$refText}`);
    }
    return ref.ref;
}
exports.resolved = resolved;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getLiteral(expr) {
    switch (expr === null || expr === void 0 ? void 0 : expr.$type) {
        case 'ObjectExpr':
            return getObjectLiteral(expr);
        case 'StringLiteral':
        case 'BooleanLiteral':
            return expr.value;
        case 'NumberLiteral':
            return parseFloat(expr.value);
        default:
            return undefined;
    }
}
exports.getLiteral = getLiteral;
function getArray(expr) {
    return (0, ast_1.isArrayExpr)(expr) || (0, ast_1.isConfigArrayExpr)(expr) ? expr.items : undefined;
}
exports.getArray = getArray;
function getLiteralArray(expr) {
    const arr = getArray(expr);
    if (!arr) {
        return undefined;
    }
    return arr.map((item) => (0, ast_1.isExpression)(item) && getLiteral(item)).filter((v) => v !== undefined);
}
exports.getLiteralArray = getLiteralArray;
function getObjectLiteral(expr) {
    if (!expr || !(0, ast_1.isObjectExpr)(expr)) {
        return undefined;
    }
    const result = {};
    for (const field of expr.fields) {
        let fieldValue;
        if ((0, ast_1.isLiteralExpr)(field.value)) {
            fieldValue = getLiteral(field.value);
        }
        else if ((0, ast_1.isArrayExpr)(field.value)) {
            fieldValue = getLiteralArray(field.value);
        }
        else if ((0, ast_1.isObjectExpr)(field.value)) {
            fieldValue = getObjectLiteral(field.value);
        }
        if (fieldValue === undefined) {
            return undefined;
        }
        else {
            result[field.name] = fieldValue;
        }
    }
    return result;
}
exports.getObjectLiteral = getObjectLiteral;
function indentString(string, count = 4) {
    const indent = ' ';
    return string.replace(/^(?!\s*$)/gm, indent.repeat(count));
}
exports.indentString = indentString;
function hasAttribute(decl, name) {
    return !!getAttribute(decl, name);
}
exports.hasAttribute = hasAttribute;
function getAttribute(decl, name) {
    return decl.attributes.find((attr) => attr.decl.$refText === name);
}
exports.getAttribute = getAttribute;
function getAttributeArgs(attr) {
    const result = {};
    for (const arg of attr.args) {
        if (!arg.$resolvedParam) {
            continue;
        }
        result[arg.$resolvedParam.name] = arg.value;
    }
    return result;
}
exports.getAttributeArgs = getAttributeArgs;
function getAttributeArg(attr, name) {
    var _a;
    for (const arg of attr.args) {
        if (((_a = arg.$resolvedParam) === null || _a === void 0 ? void 0 : _a.name) === name) {
            return arg.value;
        }
    }
    return undefined;
}
exports.getAttributeArg = getAttributeArg;
function getAttributeArgLiteral(attr, name) {
    var _a;
    for (const arg of attr.args) {
        if (((_a = arg.$resolvedParam) === null || _a === void 0 ? void 0 : _a.name) === name) {
            return getLiteral(arg.value);
        }
    }
    return undefined;
}
exports.getAttributeArgLiteral = getAttributeArgLiteral;
function isEnumFieldReference(node) {
    return (0, ast_1.isReferenceExpr)(node) && (0, ast_1.isEnumField)(node.target.ref);
}
exports.isEnumFieldReference = isEnumFieldReference;
function isDataModelFieldReference(node) {
    return (0, ast_1.isReferenceExpr)(node) && (0, ast_1.isDataModelField)(node.target.ref);
}
exports.isDataModelFieldReference = isDataModelFieldReference;
/**
 * Gets `@@id` fields declared at the data model level
 */
function getModelIdFields(model) {
    const idAttr = model.attributes.find((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@@id'; });
    if (!idAttr) {
        return [];
    }
    const fieldsArg = idAttr.args.find((a) => { var _a; return ((_a = a.$resolvedParam) === null || _a === void 0 ? void 0 : _a.name) === 'fields'; });
    if (!fieldsArg || !(0, ast_1.isArrayExpr)(fieldsArg.value)) {
        return [];
    }
    return fieldsArg.value.items
        .filter((item) => (0, ast_1.isReferenceExpr)(item))
        .map((item) => resolved(item.target));
}
exports.getModelIdFields = getModelIdFields;
/**
 * Gets `@@unique` fields declared at the data model level
 */
function getModelUniqueFields(model) {
    const uniqueAttr = model.attributes.find((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@@unique'; });
    if (!uniqueAttr) {
        return [];
    }
    const fieldsArg = uniqueAttr.args.find((a) => { var _a; return ((_a = a.$resolvedParam) === null || _a === void 0 ? void 0 : _a.name) === 'fields'; });
    if (!fieldsArg || !(0, ast_1.isArrayExpr)(fieldsArg.value)) {
        return [];
    }
    return fieldsArg.value.items
        .filter((item) => (0, ast_1.isReferenceExpr)(item))
        .map((item) => resolved(item.target));
}
exports.getModelUniqueFields = getModelUniqueFields;
/**
 * Returns if the given field is declared as an id field.
 */
function isIdField(field) {
    // field-level @id attribute
    if (hasAttribute(field, '@id')) {
        return true;
    }
    // NOTE: we have to use name to match fields because the fields
    // may be inherited from an abstract base and have cloned identities
    const model = field.$container;
    // model-level @@id attribute with a list of fields
    const modelLevelIds = getModelIdFields(model);
    if (modelLevelIds.map((f) => f.name).includes(field.name)) {
        return true;
    }
    if (model.fields.some((f) => hasAttribute(f, '@id')) || modelLevelIds.length > 0) {
        // the model already has id field, don't check @unique and @@unique
        return false;
    }
    // then, the first field with @unique can be used as id
    const firstUniqueField = model.fields.find((f) => hasAttribute(f, '@unique'));
    if (firstUniqueField) {
        return firstUniqueField.name === field.name;
    }
    // last, the first model level @@unique can be used as id
    const modelLevelUnique = getModelUniqueFields(model);
    if (modelLevelUnique.map((f) => f.name).includes(field.name)) {
        return true;
    }
    return false;
}
exports.isIdField = isIdField;
/**
 * Returns if the given field is a relation field.
 */
function isRelationshipField(field) {
    var _a;
    return (0, ast_1.isDataModel)((_a = field.type.reference) === null || _a === void 0 ? void 0 : _a.ref);
}
exports.isRelationshipField = isRelationshipField;
/**
 * Returns if the given field is a relation foreign key field.
 */
function isForeignKeyField(field) {
    const model = field.$container;
    return model.fields.some((f) => {
        // find @relation attribute
        const relAttr = f.attributes.find((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@relation'; });
        if (relAttr) {
            // find "fields" arg
            const fieldsArg = relAttr.args.find((a) => { var _a; return ((_a = a.$resolvedParam) === null || _a === void 0 ? void 0 : _a.name) === 'fields'; });
            if (fieldsArg && (0, ast_1.isArrayExpr)(fieldsArg.value)) {
                // find a matching field reference
                return fieldsArg.value.items.some((item) => {
                    if ((0, ast_1.isReferenceExpr)(item)) {
                        return item.target.ref === field;
                    }
                    else {
                        return false;
                    }
                });
            }
        }
        return false;
    });
}
exports.isForeignKeyField = isForeignKeyField;
function resolvePath(_path, options) {
    if (path_1.default.isAbsolute(_path)) {
        return _path;
    }
    else {
        return path_1.default.join(path_1.default.dirname(options.schemaPath), _path);
    }
}
exports.resolvePath = resolvePath;
function requireOption(options, name, pluginName) {
    const value = options[name];
    if (value === undefined) {
        throw new types_1.PluginError(pluginName, `Plugin "${options.name}" is missing required option: ${name}`);
    }
    return value;
}
exports.requireOption = requireOption;
function parseOptionAsStrings(options, optionaName, pluginName) {
    const value = options[optionaName];
    if (value === undefined) {
        return undefined;
    }
    else if (typeof value === 'string') {
        // comma separated string
        return value
            .split(',')
            .filter((i) => !!i)
            .map((i) => i.trim());
    }
    else if (Array.isArray(value) && value.every((i) => typeof i === 'string')) {
        // string array
        return value;
    }
    else {
        throw new types_1.PluginError(pluginName, `Invalid "${optionaName}" option: must be a comma-separated string or an array of strings`);
    }
}
exports.parseOptionAsStrings = parseOptionAsStrings;
function getFunctionExpressionContext(funcDecl) {
    const funcAllowedContext = [];
    const funcAttr = funcDecl.attributes.find((attr) => attr.decl.$refText === '@@@expressionContext');
    if (funcAttr) {
        const contextArg = funcAttr.args[0].value;
        if ((0, ast_1.isArrayExpr)(contextArg)) {
            contextArg.items.forEach((item) => {
                if (isEnumFieldReference(item)) {
                    funcAllowedContext.push(item.target.$refText);
                }
            });
        }
    }
    return funcAllowedContext;
}
exports.getFunctionExpressionContext = getFunctionExpressionContext;
function isFutureExpr(node) {
    var _a;
    return !!((0, ast_1.isInvocationExpr)(node) && ((_a = node.function.ref) === null || _a === void 0 ? void 0 : _a.name) === 'future' && isFromStdlib(node.function.ref));
}
exports.isFutureExpr = isFutureExpr;
function isFromStdlib(node) {
    const model = getContainingModel(node);
    return !!model && !!model.$document && model.$document.uri.path.endsWith(constants_1.STD_LIB_MODULE_NAME);
}
exports.isFromStdlib = isFromStdlib;
function getContainingModel(node) {
    if (!node) {
        return null;
    }
    return (0, ast_1.isModel)(node) ? node : getContainingModel(node.$container);
}
exports.getContainingModel = getContainingModel;
function getPreviewFeatures(model) {
    const jsGenerator = model.declarations.find((d) => (0, ast_1.isGeneratorDecl)(d) &&
        d.fields.some((f) => f.name === 'provider' && getLiteral(f.value) === 'prisma-client-js'));
    if (jsGenerator) {
        const previewFeaturesField = jsGenerator.fields.find((f) => f.name === 'previewFeatures');
        if (previewFeaturesField) {
            return getLiteralArray(previewFeaturesField.value);
        }
    }
    return [];
}
exports.getPreviewFeatures = getPreviewFeatures;
function getAuthModel(dataModels) {
    let authModel = dataModels.find((m) => hasAttribute(m, '@@auth'));
    if (!authModel) {
        authModel = dataModels.find((m) => m.name === 'User');
    }
    return authModel;
}
exports.getAuthModel = getAuthModel;
//# sourceMappingURL=utils.js.map