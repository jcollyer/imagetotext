"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolicyProxyHandler = void 0;
const lower_case_first_1 = require("lower-case-first");
const tiny_invariant_1 = __importDefault(require("tiny-invariant"));
const upper_case_first_1 = require("upper-case-first");
const zod_validation_error_1 = require("zod-validation-error");
const constants_1 = require("../../constants");
const cross_1 = require("../../cross");
const utils_1 = require("../utils");
const logger_1 = require("./logger");
const policy_utils_1 = require("./policy-utils");
const promise_1 = require("./promise");
/**
 * Prisma proxy handler for injecting access policy check.
 */
class PolicyProxyHandler {
    constructor(prisma, policy, modelMeta, zodSchemas, model, user, options) {
        this.prisma = prisma;
        this.policy = policy;
        this.modelMeta = modelMeta;
        this.zodSchemas = zodSchemas;
        this.user = user;
        this.options = options;
        this.DEFAULT_TX_MAXWAIT = 100000;
        this.DEFAULT_TX_TIMEOUT = 100000;
        this.logger = new logger_1.Logger(prisma);
        this.utils = new policy_utils_1.PolicyUtil(this.prisma, this.options, this.modelMeta, this.policy, this.zodSchemas, this.user, this.shouldLogQuery);
        this.model = (0, lower_case_first_1.lowerCaseFirst)(model);
    }
    get modelClient() {
        return this.prisma[this.model];
    }
    //#region Find
    // find operations behaves as if the entities that don't match access policies don't exist
    findUnique(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'query argument is required');
        }
        if (!args.where) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'where field is required in query argument');
        }
        return this.findWithFluentCallStubs(args, 'findUnique', false, () => null);
    }
    findUniqueOrThrow(args) {
        if (!args) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'query argument is required');
        }
        if (!args.where) {
            throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'where field is required in query argument');
        }
        return this.findWithFluentCallStubs(args, 'findUniqueOrThrow', true, () => {
            throw this.utils.notFound(this.model);
        });
    }
    findFirst(args) {
        return this.findWithFluentCallStubs(args, 'findFirst', false, () => null);
    }
    findFirstOrThrow(args) {
        return this.findWithFluentCallStubs(args, 'findFirstOrThrow', true, () => {
            throw this.utils.notFound(this.model);
        });
    }
    findMany(args) {
        return (0, promise_1.createDeferredPromise)(() => this.doFind(args, 'findMany', () => []));
    }
    // returns a promise for the given find operation, together with function stubs for fluent API calls
    findWithFluentCallStubs(args, actionName, resolveRoot, handleRejection) {
        // create a deferred promise so it's only evaluated when awaited or .then() is called
        const result = (0, promise_1.createDeferredPromise)(() => this.doFind(args, actionName, handleRejection));
        this.addFluentFunctions(result, this.model, args === null || args === void 0 ? void 0 : args.where, resolveRoot ? result : undefined);
        return result;
    }
    doFind(args, actionName, handleRejection) {
        const origArgs = args;
        const _args = this.utils.clone(args);
        if (!this.utils.injectForRead(this.prisma, this.model, _args)) {
            return handleRejection();
        }
        this.utils.injectReadCheckSelect(this.model, _args);
        if (this.shouldLogQuery) {
            this.logger.info(`[policy] \`${actionName}\` ${this.model}:\n${(0, utils_1.formatObject)(_args)}`);
        }
        return new Promise((resolve, reject) => {
            this.modelClient[actionName](_args).then((value) => {
                this.utils.postProcessForRead(value, this.model, origArgs);
                resolve(value);
            }, (err) => reject(err));
        });
    }
    // returns a fluent API call function
    fluentCall(filter, fieldInfo, rootPromise) {
        return (args) => {
            args = this.utils.clone(args);
            // combine the parent filter with the current one
            const backLinkField = this.requireBackLink(fieldInfo);
            const condition = backLinkField.isArray
                ? { [backLinkField.name]: { some: filter } }
                : { [backLinkField.name]: { is: filter } };
            args.where = this.utils.and(args.where, condition);
            const promise = (0, promise_1.createDeferredPromise)(() => {
                // Promise for fetching
                const fetchFluent = (resolve, reject) => {
                    const handler = this.makeHandler(fieldInfo.type);
                    if (fieldInfo.isArray) {
                        // fluent call stops here
                        handler.findMany(args).then((value) => resolve(value), (err) => reject(err));
                    }
                    else {
                        handler.findFirst(args).then((value) => resolve(value), (err) => reject(err));
                    }
                };
                return new Promise((resolve, reject) => {
                    if (rootPromise) {
                        // if a root promise exists, resolve it before fluent API call,
                        // so that fluent calls start with `findUniqueOrThrow` and `findFirstOrThrow`
                        // can throw error properly if the root promise is rejected
                        rootPromise.then(() => fetchFluent(resolve, reject), (err) => reject(err));
                    }
                    else {
                        fetchFluent(resolve, reject);
                    }
                });
            });
            if (!fieldInfo.isArray) {
                // prepare for a chained fluent API call
                this.addFluentFunctions(promise, fieldInfo.type, args.where, rootPromise);
            }
            return promise;
        };
    }
    // add fluent API functions to the given promise
    addFluentFunctions(promise, model, filter, rootPromise) {
        const fields = this.utils.getModelFields(model);
        if (fields) {
            for (const [field, fieldInfo] of Object.entries(fields)) {
                if (fieldInfo.isDataModel) {
                    promise[field] = this.fluentCall(filter, fieldInfo, rootPromise);
                }
            }
        }
    }
    //#endregion
    //#region Create
    create(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'query argument is required');
            }
            if (!args.data) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'data field is required in query argument');
            }
            this.utils.tryReject(this.prisma, this.model, 'create');
            const origArgs = args;
            args = this.utils.clone(args);
            // static input policy check for top-level create data
            const inputCheck = this.utils.checkInputGuard(this.model, args.data, 'create');
            if (inputCheck === false) {
                throw this.utils.deniedByPolicy(this.model, 'create', undefined, constants_1.CrudFailureReason.ACCESS_POLICY_VIOLATION);
            }
            const hasNestedCreateOrConnect = yield this.hasNestedCreateOrConnect(args);
            const { result, error } = yield this.transaction((tx) => __awaiter(this, void 0, void 0, function* () {
                if (
                // MUST check true here since inputCheck can be undefined (meaning static input check not possible)
                inputCheck === true &&
                    // simple create: no nested create/connect
                    !hasNestedCreateOrConnect) {
                    // there's no nested write and we've passed input check, proceed with the create directly
                    // validate zod schema if any
                    args.data = this.validateCreateInputSchema(this.model, args.data);
                    // make a create args only containing data and ID selection
                    const createArgs = { data: args.data, select: this.utils.makeIdSelection(this.model) };
                    if (this.shouldLogQuery) {
                        this.logger.info(`[policy] \`create\` ${this.model}: ${(0, utils_1.formatObject)(createArgs)}`);
                    }
                    const result = yield tx[this.model].create(createArgs);
                    // filter the read-back data
                    return this.utils.readBack(tx, this.model, 'create', args, result);
                }
                else {
                    // proceed with a complex create and collect post-write checks
                    const { result, postWriteChecks } = yield this.doCreate(this.model, args, tx);
                    // execute post-write checks
                    yield this.runPostWriteChecks(postWriteChecks, tx);
                    // filter the read-back data
                    return this.utils.readBack(tx, this.model, 'create', origArgs, result);
                }
            }));
            if (error) {
                throw error;
            }
            else {
                return result;
            }
        });
    }
    // create with nested write
    doCreate(model, args, db) {
        return __awaiter(this, void 0, void 0, function* () {
            // record id fields involved in the nesting context
            const idSelections = [];
            const pushIdFields = (model, context) => {
                const idFields = (0, cross_1.getIdFields)(this.modelMeta, model);
                idSelections.push({
                    path: context.nestingPath.map((p) => p.field).filter((f) => !!f),
                    ids: idFields.map((f) => f.name),
                });
            };
            // create a string key that uniquely identifies an entity
            const getEntityKey = (model, ids) => `${(0, upper_case_first_1.upperCaseFirst)(model)}#${Object.keys(ids)
                .sort()
                .map((f) => { var _a; return `${f}:${(_a = ids[f]) === null || _a === void 0 ? void 0 : _a.toString()}`; })
                .join('_')}`;
            // record keys of entities that are connected instead of created
            const connectedEntities = new Set();
            // visit the create payload
            const visitor = new cross_1.NestedWriteVisitor(this.modelMeta, {
                create: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    const validateResult = this.validateCreateInputSchema(model, args);
                    if (validateResult !== args) {
                        this.utils.replace(args, validateResult);
                    }
                    pushIdFields(model, context);
                }),
                createMany: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    (0, cross_1.enumerate)(args.data).forEach((item) => {
                        const r = this.validateCreateInputSchema(model, item);
                        if (r !== item) {
                            this.utils.replace(item, r);
                        }
                    });
                    pushIdFields(model, context);
                }),
                connectOrCreate: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    if (!args.where) {
                        throw this.utils.validationError(`'where' field is required for connectOrCreate`);
                    }
                    if (args.create) {
                        args.create = this.validateCreateInputSchema(model, args.create);
                    }
                    const existing = yield this.utils.checkExistence(db, model, args.where);
                    if (existing) {
                        // connect case
                        if ((_a = context.field) === null || _a === void 0 ? void 0 : _a.backLink) {
                            const backLinkField = (0, cross_1.resolveField)(this.modelMeta, model, context.field.backLink);
                            if (backLinkField === null || backLinkField === void 0 ? void 0 : backLinkField.isRelationOwner) {
                                // the target side of relation owns the relation,
                                // check if it's updatable
                                yield this.utils.checkPolicyForUnique(model, args.where, 'update', db, args);
                            }
                        }
                        this.mergeToParent(context.parent, 'connect', args.where);
                        // record the key of connected entities so we can avoid validating them later
                        connectedEntities.add(getEntityKey(model, existing));
                    }
                    else {
                        // create case
                        pushIdFields(model, context);
                        // create a new "create" clause at the parent level
                        this.mergeToParent(context.parent, 'create', args.create);
                    }
                    // remove the connectOrCreate clause
                    this.removeFromParent(context.parent, 'connectOrCreate', args);
                    // return false to prevent visiting the nested payload
                    return false;
                }),
                connect: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    var _b;
                    if (!args || typeof args !== 'object' || Object.keys(args).length === 0) {
                        throw this.utils.validationError(`'connect' field must be an non-empty object`);
                    }
                    if ((_b = context.field) === null || _b === void 0 ? void 0 : _b.backLink) {
                        const backLinkField = (0, cross_1.resolveField)(this.modelMeta, model, context.field.backLink);
                        if (backLinkField === null || backLinkField === void 0 ? void 0 : backLinkField.isRelationOwner) {
                            // check existence
                            yield this.utils.checkExistence(db, model, args, true);
                            // the target side of relation owns the relation,
                            // check if it's updatable
                            yield this.utils.checkPolicyForUnique(model, args, 'update', db, args);
                        }
                    }
                }),
            });
            yield visitor.visit(model, 'create', args);
            // build the final "select" clause including all nested ID fields
            let select = undefined;
            if (idSelections.length > 0) {
                select = {};
                idSelections.forEach(({ path, ids }) => {
                    let curr = select;
                    for (const p of path) {
                        if (!curr[p.name]) {
                            curr[p.name] = { select: {} };
                        }
                        curr = curr[p.name].select;
                    }
                    Object.assign(curr, ...ids.map((f) => ({ [f]: true })));
                });
            }
            // proceed with the create
            const createArgs = { data: args.data, select };
            if (this.shouldLogQuery) {
                this.logger.info(`[policy] \`create\` ${model}: ${(0, utils_1.formatObject)(createArgs)}`);
            }
            const result = yield db[model].create(createArgs);
            // post create policy check for the top-level and nested creates
            const postCreateChecks = new Map();
            // visit the create result and collect entities that need to be post-checked
            const modelDataVisitor = new cross_1.ModelDataVisitor(this.modelMeta);
            modelDataVisitor.visit(model, result, (model, _data, scalarData) => {
                const key = getEntityKey(model, scalarData);
                // only check if entity is created, not connected
                if (!connectedEntities.has(key) && !postCreateChecks.has(key)) {
                    postCreateChecks.set(key, { model, operation: 'create', uniqueFilter: scalarData });
                }
            });
            // return only the ids of the top-level entity
            const ids = this.utils.getEntityIds(this.model, result);
            return { result: ids, postWriteChecks: [...postCreateChecks.values()] };
        });
    }
    // Checks if the given create payload has nested create or connect
    hasNestedCreateOrConnect(args) {
        return __awaiter(this, void 0, void 0, function* () {
            let hasNestedCreateOrConnect = false;
            const visitor = new cross_1.NestedWriteVisitor(this.modelMeta, {
                create(_model, _args, context) {
                    return __awaiter(this, void 0, void 0, function* () {
                        if (context.field) {
                            hasNestedCreateOrConnect = true;
                            return false;
                        }
                        else {
                            return true;
                        }
                    });
                },
                connect() {
                    return __awaiter(this, void 0, void 0, function* () {
                        hasNestedCreateOrConnect = true;
                        return false;
                    });
                },
                connectOrCreate() {
                    return __awaiter(this, void 0, void 0, function* () {
                        hasNestedCreateOrConnect = true;
                        return false;
                    });
                },
                createMany() {
                    return __awaiter(this, void 0, void 0, function* () {
                        hasNestedCreateOrConnect = true;
                        return false;
                    });
                },
            });
            yield visitor.visit(this.model, 'create', args);
            return hasNestedCreateOrConnect;
        });
    }
    // Validates the given create payload against Zod schema if any
    validateCreateInputSchema(model, data) {
        const schema = this.utils.getZodSchema(model, 'create');
        if (schema && data) {
            const parseResult = schema.safeParse(data);
            if (!parseResult.success) {
                throw this.utils.deniedByPolicy(model, 'create', `input failed validation: ${(0, zod_validation_error_1.fromZodError)(parseResult.error)}`, constants_1.CrudFailureReason.DATA_VALIDATION_VIOLATION, parseResult.error);
            }
            return parseResult.data;
        }
        else {
            return data;
        }
    }
    createMany(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'query argument is required');
            }
            if (!args.data) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'data field is required in query argument');
            }
            this.utils.tryReject(this.prisma, this.model, 'create');
            args = this.utils.clone(args);
            // go through create items, statically check input to determine if post-create
            // check is needed, and also validate zod schema
            let needPostCreateCheck = false;
            for (const item of (0, cross_1.enumerate)(args.data)) {
                const validationResult = this.validateCreateInputSchema(this.model, item);
                if (validationResult !== item) {
                    this.utils.replace(item, validationResult);
                }
                const inputCheck = this.utils.checkInputGuard(this.model, item, 'create');
                if (inputCheck === false) {
                    // unconditionally deny
                    throw this.utils.deniedByPolicy(this.model, 'create', undefined, constants_1.CrudFailureReason.ACCESS_POLICY_VIOLATION);
                }
                else if (inputCheck === true) {
                    // unconditionally allow
                }
                else if (inputCheck === undefined) {
                    // static policy check is not possible, need to do post-create check
                    needPostCreateCheck = true;
                }
            }
            if (!needPostCreateCheck) {
                return this.modelClient.createMany(args);
            }
            else {
                // create entities in a transaction with post-create checks
                return this.transaction((tx) => __awaiter(this, void 0, void 0, function* () {
                    const { result, postWriteChecks } = yield this.doCreateMany(this.model, args, tx);
                    // post-create check
                    yield this.runPostWriteChecks(postWriteChecks, tx);
                    return result;
                }));
            }
        });
    }
    doCreateMany(model, args, db) {
        return __awaiter(this, void 0, void 0, function* () {
            // We can't call the native "createMany" because we can't get back what was created
            // for post-create checks. Instead, do a "create" for each item and collect the results.
            let createResult = yield Promise.all((0, cross_1.enumerate)(args.data).map((item) => __awaiter(this, void 0, void 0, function* () {
                if (args.skipDuplicates) {
                    if (yield this.hasDuplicatedUniqueConstraint(model, item, undefined, db)) {
                        if (this.shouldLogQuery) {
                            this.logger.info(`[policy] \`createMany\` skipping duplicate ${(0, utils_1.formatObject)(item)}`);
                        }
                        return undefined;
                    }
                }
                if (this.shouldLogQuery) {
                    this.logger.info(`[policy] \`create\` for \`createMany\` ${model}: ${(0, utils_1.formatObject)(item)}`);
                }
                return yield db[model].create({ select: this.utils.makeIdSelection(model), data: item });
            })));
            // filter undefined values due to skipDuplicates
            createResult = createResult.filter((p) => !!p);
            return {
                result: { count: createResult.length },
                postWriteChecks: createResult.map((item) => ({
                    model,
                    operation: 'create',
                    uniqueFilter: item,
                })),
            };
        });
    }
    hasDuplicatedUniqueConstraint(model, createData, upstreamQuery, db) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // check unique constraint conflicts
            // we can't rely on try/catch/ignore constraint violation error: https://github.com/prisma/prisma/issues/20496
            // TODO: for simple cases we should be able to translate it to an `upsert` with empty `update` payload
            // for each unique constraint, check if the input item has all fields set, and if so, check if
            // an entity already exists, and ignore accordingly
            const uniqueConstraints = this.utils.getUniqueConstraints(model);
            for (const constraint of Object.values(uniqueConstraints)) {
                // the unique filter used to check existence
                const uniqueFilter = {};
                // unique constraint fields not covered yet
                const remainingConstraintFields = new Set(constraint.fields);
                // collect constraint fields from the create data
                for (const [k, v] of Object.entries(createData)) {
                    if (v === undefined) {
                        continue;
                    }
                    if (remainingConstraintFields.has(k)) {
                        uniqueFilter[k] = v;
                        remainingConstraintFields.delete(k);
                    }
                }
                // collect constraint fields from the upstream query
                if (upstreamQuery) {
                    for (const [k, v] of Object.entries(upstreamQuery)) {
                        if (v === undefined) {
                            continue;
                        }
                        if (remainingConstraintFields.has(k)) {
                            uniqueFilter[k] = v;
                            remainingConstraintFields.delete(k);
                            continue;
                        }
                        // check if the upstream query contains a relation field which covers
                        // a foreign key field constraint
                        const fieldInfo = (0, cross_1.requireField)(this.modelMeta, model, k);
                        if (!fieldInfo.isDataModel) {
                            // only care about relation fields
                            continue;
                        }
                        // merge the upstream query into the unique filter
                        uniqueFilter[k] = v;
                        // mark the corresponding foreign key fields as covered
                        const fkMapping = (_a = fieldInfo.foreignKeyMapping) !== null && _a !== void 0 ? _a : {};
                        for (const fk of Object.values(fkMapping)) {
                            remainingConstraintFields.delete(fk);
                        }
                    }
                }
                if (remainingConstraintFields.size === 0) {
                    // all constraint fields set, check existence
                    const existing = yield this.utils.checkExistence(db, model, uniqueFilter);
                    if (existing) {
                        return true;
                    }
                }
            }
            return false;
        });
    }
    //#endregion
    //#region Update & Upsert
    // "update" and "upsert" work against unique entity, so we actively rejects the request if the
    // entity fails policy check
    //
    // "updateMany" works against a set of entities, entities not passing policy check are silently
    // ignored
    update(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'query argument is required');
            }
            if (!args.where) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'where field is required in query argument');
            }
            if (!args.data) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'data field is required in query argument');
            }
            args = this.utils.clone(args);
            const { result, error } = yield this.transaction((tx) => __awaiter(this, void 0, void 0, function* () {
                // proceed with nested writes and collect post-write checks
                const { result, postWriteChecks } = yield this.doUpdate(args, tx);
                // post-write check
                yield this.runPostWriteChecks(postWriteChecks, tx);
                // filter the read-back data
                return this.utils.readBack(tx, this.model, 'update', args, result);
            }));
            if (error) {
                throw error;
            }
            else {
                return result;
            }
        });
    }
    doUpdate(args, db) {
        return __awaiter(this, void 0, void 0, function* () {
            // collected post-update checks
            const postWriteChecks = [];
            // registers a post-update check task
            const _registerPostUpdateCheck = (model, preUpdateLookupFilter, postUpdateLookupFilter) => __awaiter(this, void 0, void 0, function* () {
                // both "post-update" rules and Zod schemas require a post-update check
                if (this.utils.hasAuthGuard(model, 'postUpdate') || this.utils.getZodSchema(model)) {
                    // select pre-update field values
                    let preValue;
                    const preValueSelect = this.utils.getPreValueSelect(model);
                    if (preValueSelect && Object.keys(preValueSelect).length > 0) {
                        preValue = yield db[model].findFirst({ where: preUpdateLookupFilter, select: preValueSelect });
                    }
                    postWriteChecks.push({
                        model,
                        operation: 'postUpdate',
                        uniqueFilter: postUpdateLookupFilter,
                        preValue,
                    });
                }
            });
            // We can't let the native "update" to handle nested "create" because we can't get back what
            // was created for doing post-update checks.
            // Instead, handle nested create inside update as an atomic operation that creates an entire
            // subtree (containing nested creates/connects)
            const _create = (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let createData = args;
                if ((_a = context.field) === null || _a === void 0 ? void 0 : _a.backLink) {
                    // Check if the create payload contains any "unsafe" assignment:
                    // assign id or foreign key fields.
                    //
                    // The reason why we need to do that is Prisma's mutations payload
                    // structure has two mutually exclusive forms for safe and unsafe
                    // operations. E.g.:
                    //     - safe: { data: { user: { connect: { id: 1 }} } }
                    //     - unsafe: { data: { userId: 1 } }
                    const unsafe = this.isUnsafeMutate(model, args);
                    // handles the connection to upstream entity
                    const reversedQuery = this.utils.buildReversedQuery(context, true, unsafe);
                    if ((!unsafe || context.field.isRelationOwner) && reversedQuery[context.field.backLink]) {
                        // if mutation is safe, or current field owns the relation (so the other side has no fk),
                        // and the reverse query contains the back link, then we can build a "connect" with it
                        createData = Object.assign(Object.assign({}, createData), { [context.field.backLink]: {
                                connect: reversedQuery[context.field.backLink],
                            } });
                    }
                    else {
                        // otherwise, the reverse query should be translated to foreign key setting
                        // and merged to the create data
                        const backLinkField = this.requireBackLink(context.field);
                        (0, tiny_invariant_1.default)(backLinkField.foreignKeyMapping);
                        // try to extract foreign key values from the reverse query
                        let fkValues = Object.values(backLinkField.foreignKeyMapping).reduce((obj, fk) => {
                            obj[fk] = reversedQuery[fk];
                            return obj;
                        }, {});
                        if (Object.values(fkValues).every((v) => v !== undefined)) {
                            // all foreign key values are available, merge them to the create data
                            createData = Object.assign(Object.assign({}, createData), fkValues);
                        }
                        else {
                            // some foreign key values are missing, need to look up the upstream entity,
                            // this can happen when the upstream entity doesn't have a unique where clause,
                            // for example when it's nested inside a one-to-one update
                            const upstreamQuery = {
                                where: reversedQuery[backLinkField.name],
                                select: this.utils.makeIdSelection(backLinkField.type),
                            };
                            // fetch the upstream entity
                            if (this.logger.enabled('info')) {
                                this.logger.info(`[policy] \`findUniqueOrThrow\` ${model}: looking up upstream entity of ${backLinkField.type}, ${(0, utils_1.formatObject)(upstreamQuery)}`);
                            }
                            const upstreamEntity = yield this.prisma[backLinkField.type].findUniqueOrThrow(upstreamQuery);
                            // map ids to foreign keys
                            fkValues = Object.entries(backLinkField.foreignKeyMapping).reduce((obj, [id, fk]) => {
                                obj[fk] = upstreamEntity[id];
                                return obj;
                            }, {});
                            // merge them to the create data
                            createData = Object.assign(Object.assign({}, createData), fkValues);
                        }
                    }
                }
                // proceed with the create and collect post-create checks
                const { postWriteChecks: checks } = yield this.doCreate(model, { data: createData }, db);
                postWriteChecks.push(...checks);
            });
            const _createMany = (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                for (const item of (0, cross_1.enumerate)(args.data)) {
                    if (args.skipDuplicates) {
                        // get a reversed query to include fields inherited from upstream mutation,
                        // it'll be merged with the create payload for unique constraint checking
                        const upstreamQuery = this.utils.buildReversedQuery(context);
                        if (yield this.hasDuplicatedUniqueConstraint(model, item, upstreamQuery, db)) {
                            if (this.shouldLogQuery) {
                                this.logger.info(`[policy] \`createMany\` skipping duplicate ${(0, utils_1.formatObject)(item)}`);
                            }
                            continue;
                        }
                    }
                    yield _create(model, item, context);
                }
            });
            const _connectDisconnect = (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                var _b;
                if ((_b = context.field) === null || _b === void 0 ? void 0 : _b.backLink) {
                    const backLinkField = this.utils.getModelField(model, context.field.backLink);
                    if (backLinkField.isRelationOwner) {
                        // update happens on the related model, require updatable,
                        // translate args to foreign keys so field-level policies can be checked
                        const checkArgs = {};
                        if (args && typeof args === 'object' && backLinkField.foreignKeyMapping) {
                            for (const key of Object.keys(args)) {
                                const fk = backLinkField.foreignKeyMapping[key];
                                if (fk) {
                                    checkArgs[fk] = args[key];
                                }
                            }
                        }
                        yield this.utils.checkPolicyForUnique(model, args, 'update', db, checkArgs);
                        // register post-update check
                        yield _registerPostUpdateCheck(model, args, args);
                    }
                }
            });
            // visit nested writes
            const visitor = new cross_1.NestedWriteVisitor(this.modelMeta, {
                update: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    var _c;
                    // build a unique query including upstream conditions
                    const uniqueFilter = this.utils.buildReversedQuery(context);
                    // handle not-found
                    const existing = yield this.utils.checkExistence(db, model, uniqueFilter, true);
                    // check if the update actually writes to this model
                    let thisModelUpdate = false;
                    const updatePayload = (_c = args.data) !== null && _c !== void 0 ? _c : args;
                    const validatedPayload = this.validateUpdateInputSchema(model, updatePayload);
                    if (validatedPayload !== updatePayload) {
                        this.utils.replace(updatePayload, validatedPayload);
                    }
                    if (updatePayload) {
                        for (const key of Object.keys(updatePayload)) {
                            const field = (0, cross_1.resolveField)(this.modelMeta, model, key);
                            if (field) {
                                if (!field.isDataModel) {
                                    // scalar field, require this model to be updatable
                                    thisModelUpdate = true;
                                    break;
                                }
                                else if (field.isRelationOwner) {
                                    // relation is being updated and this model owns foreign key, require updatable
                                    thisModelUpdate = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (thisModelUpdate) {
                        this.utils.tryReject(db, this.model, 'update');
                        // check pre-update guard
                        yield this.utils.checkPolicyForUnique(model, uniqueFilter, 'update', db, args);
                        // handles the case where id fields are updated
                        const postUpdateIds = this.utils.clone(existing);
                        for (const key of Object.keys(existing)) {
                            const updateValue = args.data ? args.data[key] : args[key];
                            if (typeof updateValue === 'string' ||
                                typeof updateValue === 'number' ||
                                typeof updateValue === 'bigint') {
                                postUpdateIds[key] = updateValue;
                            }
                        }
                        // register post-update check
                        yield _registerPostUpdateCheck(model, existing, postUpdateIds);
                    }
                }),
                updateMany: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    // prepare for post-update check
                    if (this.utils.hasAuthGuard(model, 'postUpdate') || this.utils.getZodSchema(model)) {
                        let select = this.utils.makeIdSelection(model);
                        const preValueSelect = this.utils.getPreValueSelect(model);
                        if (preValueSelect) {
                            select = Object.assign(Object.assign({}, select), preValueSelect);
                        }
                        const reversedQuery = this.utils.buildReversedQuery(context);
                        const currentSetQuery = { select, where: reversedQuery };
                        this.utils.injectAuthGuardAsWhere(db, currentSetQuery, model, 'read');
                        if (this.shouldLogQuery) {
                            this.logger.info(`[policy] \`findMany\` for post update check ${model}:\n${(0, utils_1.formatObject)(currentSetQuery)}`);
                        }
                        const currentSet = yield db[model].findMany(currentSetQuery);
                        postWriteChecks.push(...currentSet.map((preValue) => ({
                            model,
                            operation: 'postUpdate',
                            uniqueFilter: preValue,
                            preValue: preValueSelect ? preValue : undefined,
                        })));
                    }
                    args.data = this.validateUpdateInputSchema(model, args.data);
                    const updateGuard = this.utils.getAuthGuard(db, model, 'update');
                    if (this.utils.isTrue(updateGuard) || this.utils.isFalse(updateGuard)) {
                        // injects simple auth guard into where clause
                        this.utils.injectAuthGuardAsWhere(db, args, model, 'update');
                    }
                    else {
                        // we have to process `updateMany` separately because the guard may contain
                        // filters using relation fields which are not allowed in nested `updateMany`
                        const reversedQuery = this.utils.buildReversedQuery(context);
                        const updateWhere = this.utils.and(reversedQuery, updateGuard);
                        if (this.shouldLogQuery) {
                            this.logger.info(`[policy] \`updateMany\` ${model}:\n${(0, utils_1.formatObject)({
                                where: updateWhere,
                                data: args.data,
                            })}`);
                        }
                        yield db[model].updateMany({ where: updateWhere, data: args.data });
                        delete context.parent.updateMany;
                    }
                }),
                create: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    // process the entire create subtree separately
                    yield _create(model, args, context);
                    // remove it from the update payload
                    this.removeFromParent(context.parent, 'create', args);
                    // don't visit payload
                    return false;
                }),
                createMany: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    // process createMany separately
                    yield _createMany(model, args, context);
                    // remove it from the update payload
                    delete context.parent.createMany;
                    // don't visit payload
                    return false;
                }),
                upsert: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    // build a unique query including upstream conditions
                    const uniqueFilter = this.utils.buildReversedQuery(context);
                    // branch based on if the update target exists
                    const existing = yield this.utils.checkExistence(db, model, uniqueFilter);
                    if (existing) {
                        // update case
                        // check pre-update guard
                        yield this.utils.checkPolicyForUnique(model, uniqueFilter, 'update', db, args);
                        // register post-update check
                        yield _registerPostUpdateCheck(model, uniqueFilter, uniqueFilter);
                        // convert upsert to update
                        const convertedUpdate = {
                            where: args.where,
                            data: this.validateUpdateInputSchema(model, args.update),
                        };
                        this.mergeToParent(context.parent, 'update', convertedUpdate);
                        this.removeFromParent(context.parent, 'upsert', args);
                        // continue visiting the new payload
                        return convertedUpdate;
                    }
                    else {
                        // create case
                        // process the entire create subtree separately
                        yield _create(model, args.create, context);
                        // remove it from the update payload
                        this.removeFromParent(context.parent, 'upsert', args);
                        // don't visit payload
                        return false;
                    }
                }),
                connect: (model, args, context) => __awaiter(this, void 0, void 0, function* () { return _connectDisconnect(model, args, context); }),
                connectOrCreate: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    // the where condition is already unique, so we can use it to check if the target exists
                    const existing = yield this.utils.checkExistence(db, model, args.where);
                    if (existing) {
                        // connect
                        yield _connectDisconnect(model, args.where, context);
                    }
                    else {
                        // create
                        yield _create(model, args.create, context);
                    }
                }),
                disconnect: (model, args, context) => __awaiter(this, void 0, void 0, function* () { return _connectDisconnect(model, args, context); }),
                set: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    // find the set of items to be replaced
                    const reversedQuery = this.utils.buildReversedQuery(context);
                    const findCurrSetArgs = {
                        select: this.utils.makeIdSelection(model),
                        where: reversedQuery,
                    };
                    if (this.shouldLogQuery) {
                        this.logger.info(`[policy] \`findMany\` ${model}:\n${(0, utils_1.formatObject)(findCurrSetArgs)}`);
                    }
                    const currentSet = yield db[model].findMany(findCurrSetArgs);
                    // register current set for update (foreign key)
                    yield Promise.all(currentSet.map((item) => _connectDisconnect(model, item, context)));
                    // proceed with connecting the new set
                    yield Promise.all((0, cross_1.enumerate)(args).map((item) => _connectDisconnect(model, item, context)));
                }),
                delete: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    // build a unique query including upstream conditions
                    const uniqueFilter = this.utils.buildReversedQuery(context);
                    // handle not-found
                    yield this.utils.checkExistence(db, model, uniqueFilter, true);
                    // check delete guard
                    yield this.utils.checkPolicyForUnique(model, uniqueFilter, 'delete', db, args);
                }),
                deleteMany: (model, args, context) => __awaiter(this, void 0, void 0, function* () {
                    const guard = yield this.utils.getAuthGuard(db, model, 'delete');
                    if (this.utils.isTrue(guard) || this.utils.isFalse(guard)) {
                        // inject simple auth guard
                        context.parent.deleteMany = this.utils.and(args, guard);
                    }
                    else {
                        // we have to process `deleteMany` separately because the guard may contain
                        // filters using relation fields which are not allowed in nested `deleteMany`
                        const reversedQuery = this.utils.buildReversedQuery(context);
                        const deleteWhere = this.utils.and(reversedQuery, guard);
                        if (this.shouldLogQuery) {
                            this.logger.info(`[policy] \`deleteMany\` ${model}:\n${(0, utils_1.formatObject)({ where: deleteWhere })}`);
                        }
                        yield db[model].deleteMany({ where: deleteWhere });
                        delete context.parent.deleteMany;
                    }
                }),
            });
            yield visitor.visit(this.model, 'update', args);
            // finally proceed with the update
            if (this.shouldLogQuery) {
                this.logger.info(`[policy] \`update\` ${this.model}: ${(0, utils_1.formatObject)(args)}`);
            }
            const result = yield db[this.model].update({
                where: args.where,
                data: args.data,
                select: this.utils.makeIdSelection(this.model),
            });
            return { result, postWriteChecks };
        });
    }
    // Validates the given update payload against Zod schema if any
    validateUpdateInputSchema(model, data) {
        const schema = this.utils.getZodSchema(model, 'update');
        if (schema && data) {
            // update payload can contain non-literal fields, like:
            //   { x: { increment: 1 } }
            // we should only validate literal fields
            const literalData = Object.entries(data).reduce((acc, [k, v]) => (Object.assign(Object.assign({}, acc), (typeof v !== 'object' ? { [k]: v } : {}))), {});
            const parseResult = schema.safeParse(literalData);
            if (!parseResult.success) {
                throw this.utils.deniedByPolicy(model, 'update', `input failed validation: ${(0, zod_validation_error_1.fromZodError)(parseResult.error)}`, constants_1.CrudFailureReason.DATA_VALIDATION_VIOLATION, parseResult.error);
            }
            // schema may have transformed field values, use it to overwrite the original data
            return Object.assign(Object.assign({}, data), parseResult.data);
        }
        else {
            return data;
        }
    }
    isUnsafeMutate(model, args) {
        if (!args) {
            return false;
        }
        for (const k of Object.keys(args)) {
            const field = (0, cross_1.resolveField)(this.modelMeta, model, k);
            if (this.isAutoIncrementIdField(field) || (field === null || field === void 0 ? void 0 : field.isForeignKey)) {
                return true;
            }
        }
        return false;
    }
    isAutoIncrementIdField(field) {
        return field.isId && field.isAutoIncrement;
    }
    updateMany(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'query argument is required');
            }
            if (!args.data) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'data field is required in query argument');
            }
            this.utils.tryReject(this.prisma, this.model, 'update');
            args = this.utils.clone(args);
            this.utils.injectAuthGuardAsWhere(this.prisma, args, this.model, 'update');
            args.data = this.validateUpdateInputSchema(this.model, args.data);
            if (this.utils.hasAuthGuard(this.model, 'postUpdate') || this.utils.getZodSchema(this.model)) {
                // use a transaction to do post-update checks
                const postWriteChecks = [];
                return this.transaction((tx) => __awaiter(this, void 0, void 0, function* () {
                    // collect pre-update values
                    let select = this.utils.makeIdSelection(this.model);
                    const preValueSelect = this.utils.getPreValueSelect(this.model);
                    if (preValueSelect) {
                        select = Object.assign(Object.assign({}, select), preValueSelect);
                    }
                    const currentSetQuery = { select, where: args.where };
                    this.utils.injectAuthGuardAsWhere(tx, currentSetQuery, this.model, 'read');
                    if (this.shouldLogQuery) {
                        this.logger.info(`[policy] \`findMany\` ${this.model}: ${(0, utils_1.formatObject)(currentSetQuery)}`);
                    }
                    const currentSet = yield tx[this.model].findMany(currentSetQuery);
                    postWriteChecks.push(...currentSet.map((preValue) => ({
                        model: this.model,
                        operation: 'postUpdate',
                        uniqueFilter: this.utils.getEntityIds(this.model, preValue),
                        preValue: preValueSelect ? preValue : undefined,
                    })));
                    // proceed with the update
                    const result = yield tx[this.model].updateMany(args);
                    // run post-write checks
                    yield this.runPostWriteChecks(postWriteChecks, tx);
                    return result;
                }));
            }
            else {
                // proceed without a transaction
                if (this.shouldLogQuery) {
                    this.logger.info(`[policy] \`updateMany\` ${this.model}: ${(0, utils_1.formatObject)(args)}`);
                }
                return this.modelClient.updateMany(args);
            }
        });
    }
    upsert(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'query argument is required');
            }
            if (!args.where) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'where field is required in query argument');
            }
            if (!args.create) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'create field is required in query argument');
            }
            if (!args.update) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'update field is required in query argument');
            }
            this.utils.tryReject(this.prisma, this.model, 'create');
            this.utils.tryReject(this.prisma, this.model, 'update');
            args = this.utils.clone(args);
            // We can call the native "upsert" because we can't tell if an entity was created or updated
            // for doing post-write check accordingly. Instead, decompose it into create or update.
            const { result, error } = yield this.transaction((tx) => __awaiter(this, void 0, void 0, function* () {
                const { where, create, update } = args, rest = __rest(args, ["where", "create", "update"]);
                const existing = yield this.utils.checkExistence(tx, this.model, args.where);
                if (existing) {
                    // update case
                    const { result, postWriteChecks } = yield this.doUpdate(Object.assign({ where, data: update }, rest), tx);
                    yield this.runPostWriteChecks(postWriteChecks, tx);
                    return this.utils.readBack(tx, this.model, 'update', args, result);
                }
                else {
                    // create case
                    const { result, postWriteChecks } = yield this.doCreate(this.model, Object.assign({ data: create }, rest), tx);
                    yield this.runPostWriteChecks(postWriteChecks, tx);
                    return this.utils.readBack(tx, this.model, 'create', args, result);
                }
            }));
            if (error) {
                throw error;
            }
            else {
                return result;
            }
        });
    }
    //#endregion
    //#region Delete
    // "delete" works against a single entity, and is rejected if the entity fails policy check.
    // "deleteMany" works against a set of entities, entities that fail policy check are filtered out.
    delete(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'query argument is required');
            }
            if (!args.where) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'where field is required in query argument');
            }
            this.utils.tryReject(this.prisma, this.model, 'delete');
            const { result, error } = yield this.transaction((tx) => __awaiter(this, void 0, void 0, function* () {
                // do a read-back before delete
                const r = yield this.utils.readBack(tx, this.model, 'delete', args, args.where);
                const error = r.error;
                const read = r.result;
                // check existence
                yield this.utils.checkExistence(tx, this.model, args.where, true);
                // inject delete guard
                yield this.utils.checkPolicyForUnique(this.model, args.where, 'delete', tx, args);
                // proceed with the deletion
                if (this.shouldLogQuery) {
                    this.logger.info(`[policy] \`delete\` ${this.model}:\n${(0, utils_1.formatObject)(args)}`);
                }
                yield tx[this.model].delete(args);
                return { result: read, error };
            }));
            if (error) {
                throw error;
            }
            else {
                return result;
            }
        });
    }
    deleteMany(args) {
        return __awaiter(this, void 0, void 0, function* () {
            this.utils.tryReject(this.prisma, this.model, 'delete');
            // inject policy conditions
            args = args !== null && args !== void 0 ? args : {};
            this.utils.injectAuthGuardAsWhere(this.prisma, args, this.model, 'delete');
            // conduct the deletion
            if (this.shouldLogQuery) {
                this.logger.info(`[policy] \`deleteMany\` ${this.model}:\n${(0, utils_1.formatObject)(args)}`);
            }
            return this.modelClient.deleteMany(args);
        });
    }
    //#endregion
    //#region Aggregation
    aggregate(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'query argument is required');
            }
            args = this.utils.clone(args);
            // inject policy conditions
            this.utils.injectAuthGuardAsWhere(this.prisma, args, this.model, 'read');
            if (this.shouldLogQuery) {
                this.logger.info(`[policy] \`aggregate\` ${this.model}:\n${(0, utils_1.formatObject)(args)}`);
            }
            return this.modelClient.aggregate(args);
        });
    }
    groupBy(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args) {
                throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'query argument is required');
            }
            args = this.utils.clone(args);
            // inject policy conditions
            this.utils.injectAuthGuardAsWhere(this.prisma, args, this.model, 'read');
            if (this.shouldLogQuery) {
                this.logger.info(`[policy] \`groupBy\` ${this.model}:\n${(0, utils_1.formatObject)(args)}`);
            }
            return this.modelClient.groupBy(args);
        });
    }
    count(args) {
        return __awaiter(this, void 0, void 0, function* () {
            // inject policy conditions
            args = args ? this.utils.clone(args) : {};
            this.utils.injectAuthGuardAsWhere(this.prisma, args, this.model, 'read');
            if (this.shouldLogQuery) {
                this.logger.info(`[policy] \`count\` ${this.model}:\n${(0, utils_1.formatObject)(args)}`);
            }
            return this.modelClient.count(args);
        });
    }
    //#endregion
    //#region Subscribe (Prisma Pulse)
    subscribe(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const readGuard = this.utils.getAuthGuard(this.prisma, this.model, 'read');
            if (this.utils.isTrue(readGuard)) {
                // no need to inject
                if (this.shouldLogQuery) {
                    this.logger.info(`[policy] \`subscribe\` ${this.model}:\n${(0, utils_1.formatObject)(args)}`);
                }
                return this.modelClient.subscribe(args);
            }
            if (!args) {
                // include all
                args = { create: {}, update: {}, delete: {} };
            }
            else {
                if (typeof args !== 'object') {
                    throw (0, utils_1.prismaClientValidationError)(this.prisma, this.options, 'argument must be an object');
                }
                if (Object.keys(args).length === 0) {
                    // include all
                    args = { create: {}, update: {}, delete: {} };
                }
                else {
                    args = this.utils.clone(args);
                }
            }
            // inject into subscribe conditions
            if (args.create) {
                args.create.after = this.utils.and(args.create.after, readGuard);
            }
            if (args.update) {
                args.update.after = this.utils.and(args.update.after, readGuard);
            }
            if (args.delete) {
                args.delete.before = this.utils.and(args.delete.before, readGuard);
            }
            if (this.shouldLogQuery) {
                this.logger.info(`[policy] \`subscribe\` ${this.model}:\n${(0, utils_1.formatObject)(args)}`);
            }
            return this.modelClient.subscribe(args);
        });
    }
    //#endregion
    //#region Utils
    get shouldLogQuery() {
        var _a;
        return !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.logPrismaQuery) && this.logger.enabled('info');
    }
    transaction(action) {
        var _a, _b, _c;
        if (this.prisma['$transaction']) {
            const txOptions = { maxWait: this.DEFAULT_TX_MAXWAIT, timeout: this.DEFAULT_TX_TIMEOUT };
            if (((_a = this.options) === null || _a === void 0 ? void 0 : _a.transactionMaxWait) !== undefined) {
                txOptions.maxWait = this.options.transactionMaxWait;
            }
            if (((_b = this.options) === null || _b === void 0 ? void 0 : _b.transactionTimeout) !== undefined) {
                txOptions.timeout = this.options.transactionTimeout;
            }
            if (((_c = this.options) === null || _c === void 0 ? void 0 : _c.transactionIsolationLevel) !== undefined) {
                txOptions.isolationLevel = this.options.transactionIsolationLevel;
            }
            return this.prisma.$transaction((tx) => action(tx), txOptions);
        }
        else {
            // already in transaction, don't nest
            return action(this.prisma);
        }
    }
    runPostWriteChecks(postWriteChecks, db) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(postWriteChecks.map(({ model, operation, uniqueFilter, preValue }) => __awaiter(this, void 0, void 0, function* () { return this.utils.checkPolicyForUnique(model, uniqueFilter, operation, db, undefined, preValue); })));
        });
    }
    makeHandler(model) {
        return new PolicyProxyHandler(this.prisma, this.policy, this.modelMeta, this.zodSchemas, model, this.user, this.options);
    }
    requireBackLink(fieldInfo) {
        (0, tiny_invariant_1.default)(fieldInfo.backLink, `back link not found for field ${fieldInfo.name}`);
        return (0, cross_1.requireField)(this.modelMeta, fieldInfo.type, fieldInfo.backLink);
    }
    mergeToParent(parent, key, value) {
        if (parent[key]) {
            if (Array.isArray(parent[key])) {
                parent[key].push(value);
            }
            else {
                parent[key] = [parent[key], value];
            }
        }
        else {
            parent[key] = value;
        }
    }
    removeFromParent(parent, key, data) {
        if (parent[key] === data) {
            delete parent[key];
        }
        else if (Array.isArray(parent[key])) {
            const idx = parent[key].indexOf(data);
            if (idx >= 0) {
                parent[key].splice(idx, 1);
                if (parent[key].length === 0) {
                    delete parent[key];
                }
            }
        }
    }
}
exports.PolicyProxyHandler = PolicyProxyHandler;
//# sourceMappingURL=handler.js.map