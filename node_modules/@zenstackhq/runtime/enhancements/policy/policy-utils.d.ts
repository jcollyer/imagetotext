import { ZodError } from 'zod';
import type { EnhancementOptions } from '..';
import { CrudFailureReason } from '../../constants';
import { type FieldInfo, type ModelMeta, type NestedWriteVisitorContext } from '../../cross';
import { AuthUser, DbClientContract, DbOperations, PolicyOperationKind } from '../../types';
import type { PolicyDef, ZodSchemas } from '../types';
/**
 * Access policy enforcement utilities
 */
export declare class PolicyUtil {
    private readonly db;
    private readonly options;
    private readonly modelMeta;
    private readonly policy;
    private readonly zodSchemas;
    private readonly user?;
    private readonly shouldLogQuery;
    private readonly logger;
    constructor(db: DbClientContract, options: EnhancementOptions | undefined, modelMeta: ModelMeta, policy: PolicyDef, zodSchemas: ZodSchemas | undefined, user?: AuthUser | undefined, shouldLogQuery?: boolean);
    /**
     * Creates a conjunction of a list of query conditions.
     */
    and(...conditions: (boolean | object | undefined)[]): object;
    /**
     * Creates a disjunction of a list of query conditions.
     */
    or(...conditions: (boolean | object | undefined)[]): object;
    /**
     * Creates a negation of a query condition.
     */
    not(condition: object | boolean | undefined): object;
    isTrue(condition: object): boolean;
    isFalse(condition: object): boolean;
    private makeTrue;
    private makeFalse;
    private reduce;
    /**
     * Gets pregenerated authorization guard object for a given model and operation.
     *
     * @returns true if operation is unconditionally allowed, false if unconditionally denied,
     * otherwise returns a guard object
     */
    getAuthGuard(db: Record<string, DbOperations>, model: string, operation: PolicyOperationKind, preValue?: any): object;
    /**
     * Get field-level read auth guard that overrides the model-level
     */
    getFieldOverrideReadAuthGuard(db: Record<string, DbOperations>, model: string, field: string): object;
    /**
     * Get field-level update auth guard
     */
    getFieldUpdateAuthGuard(db: Record<string, DbOperations>, model: string, field: string): object;
    /**
     * Get field-level update auth guard that overrides the model-level
     */
    getFieldOverrideUpdateAuthGuard(db: Record<string, DbOperations>, model: string, field: string): object;
    /**
     * Checks if the given model has a policy guard for the given operation.
     */
    hasAuthGuard(model: string, operation: PolicyOperationKind): boolean;
    /**
     * Checks if the given model has any field-level override policy guard for the given operation.
     */
    hasOverrideAuthGuard(model: string, operation: PolicyOperationKind): boolean;
    /**
     * Checks model creation policy based on static analysis to the input args.
     *
     * @returns boolean if static analysis is enough to determine the result, undefined if not
     */
    checkInputGuard(model: string, args: any, operation: 'create'): boolean | undefined;
    /**
     * Injects model auth guard as where clause.
     */
    injectAuthGuardAsWhere(db: Record<string, DbOperations>, args: any, model: string, operation: PolicyOperationKind): boolean;
    private injectGuardForRelationFields;
    private injectGuardForToManyField;
    private injectGuardForToOneField;
    /**
     * Injects auth guard for read operations.
     */
    injectForRead(db: Record<string, DbOperations>, model: string, args: any): boolean;
    private flattenGeneratedUniqueField;
    /**
     * Gets unique constraints for the given model.
     */
    getUniqueConstraints(model: string): Record<string, import("..").UniqueConstraint>;
    /**
     * Builds a reversed query for the given nested path.
     */
    buildReversedQuery(context: NestedWriteVisitorContext, forMutationPayload?: boolean, unsafeOperation?: boolean): any;
    private injectNestedReadConditions;
    /**
     * Given a model and a unique filter, checks the operation is allowed by policies and field validations.
     * Rejects with an error if not allowed.
     */
    checkPolicyForUnique(model: string, uniqueFilter: any, operation: PolicyOperationKind, db: Record<string, DbOperations>, args: any, preValue?: any): Promise<void>;
    private getFieldReadGuards;
    private getFieldUpdateGuards;
    /**
     * Tries rejecting a request based on static "false" policy.
     */
    tryReject(db: Record<string, DbOperations>, model: string, operation: PolicyOperationKind): void;
    /**
     * Checks if a model exists given a unique filter.
     */
    checkExistence(db: Record<string, DbOperations>, model: string, uniqueFilter: any, throwIfNotFound?: boolean): Promise<any>;
    /**
     * Returns an entity given a unique filter with read policy checked. Reject if not readable.
     */
    readBack(db: Record<string, DbOperations>, model: string, operation: PolicyOperationKind, selectInclude: {
        select?: any;
        include?: any;
    }, uniqueFilter: any): Promise<{
        result: unknown;
        error?: Error;
    }>;
    /**
     * Injects field selection needed for checking field-level read policy into query args.
     * @returns
     */
    injectReadCheckSelect(model: string, args: any): void;
    private doInjectReadCheckSelect;
    private makeAllScalarFieldSelect;
    deniedByPolicy(model: string, operation: PolicyOperationKind, extra?: string, reason?: CrudFailureReason, zodErrors?: ZodError): Error;
    notFound(model: string): Error;
    validationError(message: string): void;
    unknownError(message: string): void;
    /**
     * Gets field selection for fetching pre-update entity values for the given model.
     */
    getPreValueSelect(model: string): object | undefined;
    private getReadFieldSelect;
    private checkReadField;
    private hasFieldValidation;
    private hasFieldLevelPolicy;
    /**
     * Gets Zod schema for the given model and access kind.
     *
     * @param kind If undefined, returns the full schema.
     */
    getZodSchema(model: string, kind?: 'create' | 'update' | undefined): import("zod").ZodType<any, import("zod").ZodTypeDef, any> | undefined;
    /**
     * Post processing checks and clean-up for read model entities.
     */
    postProcessForRead(data: any, model: string, queryArgs: any): void;
    private doPostProcessForRead;
    /**
     * Gets information for all fields of a model.
     */
    getModelFields(model: string): Record<string, FieldInfo>;
    /**
     * Gets information for a specific model field.
     */
    getModelField(model: string, field: string): FieldInfo;
    /**
     * Clones an object and makes sure it's not empty.
     */
    clone(value: unknown): any;
    /**
     * Replace content of `target` object with `withObject` in-place.
     */
    replace(target: any, withObject: any): void;
    /**
     * Picks properties from an object.
     */
    pick<T>(value: T, ...props: (keyof T)[]): Pick<T, (typeof props)[number]>;
    /**
     * Gets "id" fields for a given model.
     */
    getIdFields(model: string): FieldInfo[];
    /**
     * Gets id field values from an entity.
     */
    getEntityIds(model: string, entityData: any): Record<string, unknown>;
    /**
     * Creates a selection object for id fields for the given model.
     */
    makeIdSelection(model: string): any;
    private mergeWhereClause;
    private requireGuard;
}
