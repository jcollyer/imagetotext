"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginRunner = void 0;
const ast_1 = require("@zenstackhq/language/ast");
const sdk_1 = require("@zenstackhq/sdk");
const colors_1 = __importDefault(require("colors"));
const fs_1 = __importDefault(require("fs"));
const ora_1 = __importDefault(require("ora"));
const path_1 = __importDefault(require("path"));
const plugin_utils_1 = require("../plugins/plugin-utils");
const schema_generator_1 = require("../plugins/prisma/schema-generator");
const telemetry_1 = __importDefault(require("../telemetry"));
const version_utils_1 = require("../utils/version-utils");
/**
 * ZenStack plugin runner
 */
class PluginRunner {
    /**
     * Runs a series of nested generators
     */
    run(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = (0, version_utils_1.getVersion)();
            console.log(colors_1.default.bold(`⌛️ ZenStack CLI v${version}, running plugins`));
            (0, plugin_utils_1.ensureDefaultOutputFolder)(options);
            const plugins = [];
            const pluginDecls = options.schema.declarations.filter((d) => (0, ast_1.isPlugin)(d));
            let prismaOutput = (0, schema_generator_1.getDefaultPrismaOutputFile)(options.schemaPath);
            for (const pluginDecl of pluginDecls) {
                const pluginProvider = this.getPluginProvider(pluginDecl);
                if (!pluginProvider) {
                    console.error(`Plugin ${pluginDecl.name} has invalid provider option`);
                    throw new sdk_1.PluginError('', `Plugin ${pluginDecl.name} has invalid provider option`);
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                let pluginModule;
                try {
                    pluginModule = this.loadPluginModule(pluginProvider, options);
                }
                catch (err) {
                    console.error(`Unable to load plugin module ${pluginProvider}: ${err}`);
                    throw new sdk_1.PluginError('', `Unable to load plugin module ${pluginProvider}`);
                }
                if (!pluginModule.default || typeof pluginModule.default !== 'function') {
                    console.error(`Plugin provider ${pluginProvider} is missing a default function export`);
                    throw new sdk_1.PluginError('', `Plugin provider ${pluginProvider} is missing a default function export`);
                }
                const dependencies = this.getPluginDependencies(pluginModule);
                const pluginName = this.getPluginName(pluginModule, pluginProvider);
                const pluginOptions = { schemaPath: options.schemaPath, name: pluginName };
                pluginDecl.fields.forEach((f) => {
                    var _a;
                    const value = (_a = (0, sdk_1.getLiteral)(f.value)) !== null && _a !== void 0 ? _a : (0, sdk_1.getLiteralArray)(f.value);
                    if (value === undefined) {
                        throw new sdk_1.PluginError(pluginName, `Invalid option value for ${f.name}`);
                    }
                    pluginOptions[f.name] = value;
                });
                plugins.push({
                    name: pluginName,
                    provider: pluginProvider,
                    dependencies,
                    options: pluginOptions,
                    run: pluginModule.default,
                    module: pluginModule,
                });
                if (pluginProvider === '@core/prisma' && typeof pluginOptions.output === 'string') {
                    // record custom prisma output path
                    prismaOutput = (0, sdk_1.resolvePath)(pluginOptions.output, pluginOptions);
                }
            }
            // get core plugins that need to be enabled
            const corePlugins = this.calculateCorePlugins(options, plugins);
            // shift/insert core plugins to the front
            for (const corePlugin of corePlugins.reverse()) {
                const existingIdx = plugins.findIndex((p) => p.provider === corePlugin.provider);
                if (existingIdx >= 0) {
                    // shift the plugin to the front
                    const existing = plugins[existingIdx];
                    plugins.splice(existingIdx, 1);
                    plugins.unshift(existing);
                }
                else {
                    // synthesize a plugin and insert front
                    const pluginModule = require(this.getPluginModulePath(corePlugin.provider, options));
                    const pluginName = this.getPluginName(pluginModule, corePlugin.provider);
                    plugins.unshift({
                        name: pluginName,
                        provider: corePlugin.provider,
                        dependencies: [],
                        options: Object.assign({ schemaPath: options.schemaPath, name: pluginName }, corePlugin.options),
                        run: pluginModule.default,
                        module: pluginModule,
                    });
                }
            }
            // check dependencies
            for (const plugin of plugins) {
                for (const dep of plugin.dependencies) {
                    if (!plugins.find((p) => p.provider === dep)) {
                        console.error(`Plugin ${plugin.provider} depends on "${dep}" but it's not declared`);
                        throw new sdk_1.PluginError(plugin.name, `Plugin ${plugin.provider} depends on "${dep}" but it's not declared`);
                    }
                }
            }
            if (plugins.length === 0) {
                console.log(colors_1.default.yellow('No plugins configured.'));
                return;
            }
            const warnings = [];
            let dmmf = undefined;
            for (const { name, provider, run, options: pluginOptions } of plugins) {
                // const start = Date.now();
                yield this.runPlugin(name, run, options, pluginOptions, dmmf, warnings);
                // console.log(`✅ Plugin ${colors.bold(name)} (${provider}) completed in ${Date.now() - start}ms`);
                if (provider === '@core/prisma') {
                    // load prisma DMMF
                    dmmf = yield (0, sdk_1.getDMMF)({
                        datamodel: fs_1.default.readFileSync(prismaOutput, { encoding: 'utf-8' }),
                    });
                }
            }
            console.log(colors_1.default.green(colors_1.default.bold('\n👻 All plugins completed successfully!')));
            warnings.forEach((w) => console.warn(colors_1.default.yellow(w)));
            console.log(`Don't forget to restart your dev server to let the changes take effect.`);
        });
    }
    calculateCorePlugins(options, plugins) {
        const corePlugins = [];
        if (options.defaultPlugins) {
            corePlugins.push({ provider: '@core/prisma' }, { provider: '@core/model-meta' }, { provider: '@core/access-policy' });
        }
        else if (plugins.length > 0) {
            // "@core/prisma" plugin is always enabled if any plugin is configured
            corePlugins.push({ provider: '@core/prisma' });
        }
        // "@core/access-policy" has implicit requirements
        let zodImplicitlyAdded = false;
        if ([...plugins, ...corePlugins].find((p) => p.provider === '@core/access-policy')) {
            // make sure "@core/model-meta" is enabled
            if (!corePlugins.find((p) => p.provider === '@core/model-meta')) {
                corePlugins.push({ provider: '@core/model-meta' });
            }
            // '@core/zod' plugin is auto-enabled by "@core/access-policy"
            // if there're validation rules
            if (!corePlugins.find((p) => p.provider === '@core/zod') && this.hasValidation(options.schema)) {
                zodImplicitlyAdded = true;
                corePlugins.push({ provider: '@core/zod', options: { modelOnly: true } });
            }
        }
        // core plugins introduced by dependencies
        plugins.forEach((plugin) => {
            // TODO: generalize this
            const isTrpcPlugin = plugin.provider === '@zenstackhq/trpc' ||
                // for testing
                (process.env.ZENSTACK_TEST && plugin.provider.includes('trpc'));
            for (const dep of plugin.dependencies) {
                if (dep.startsWith('@core/')) {
                    const existing = corePlugins.find((p) => p.provider === dep);
                    if (existing) {
                        // TODO: generalize this
                        if (existing.provider === '@core/zod') {
                            // Zod plugin can be automatically enabled in `modelOnly` mode, however
                            // other plugin (tRPC) for now requires it to run in full mode
                            existing.options = {};
                            if (isTrpcPlugin &&
                                zodImplicitlyAdded // don't do it for user defined zod plugin
                            ) {
                                // pass trpc plugin's `generateModels` option down to zod plugin
                                existing.options.generateModels = plugin.options.generateModels;
                            }
                        }
                    }
                    else {
                        // add core dependency
                        const toAdd = { provider: dep, options: {} };
                        // TODO: generalize this
                        if (dep === '@core/zod' && isTrpcPlugin) {
                            // pass trpc plugin's `generateModels` option down to zod plugin
                            toAdd.options.generateModels = plugin.options.generateModels;
                        }
                        corePlugins.push(toAdd);
                    }
                }
            }
        });
        return corePlugins;
    }
    hasValidation(schema) {
        return (0, sdk_1.getDataModels)(schema).some((model) => (0, sdk_1.hasValidationAttributes)(model));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getPluginName(pluginModule, pluginProvider) {
        return typeof pluginModule.name === 'string' ? pluginModule.name : pluginProvider;
    }
    getPluginDependencies(pluginModule) {
        return Array.isArray(pluginModule.dependencies) ? pluginModule.dependencies : [];
    }
    getPluginProvider(plugin) {
        const providerField = plugin.fields.find((f) => f.name === 'provider');
        return (0, sdk_1.getLiteral)(providerField === null || providerField === void 0 ? void 0 : providerField.value);
    }
    runPlugin(name, run, runnerOptions, options, dmmf, warnings) {
        return __awaiter(this, void 0, void 0, function* () {
            const spinner = (0, ora_1.default)(`Running plugin ${colors_1.default.cyan(name)}`).start();
            try {
                yield telemetry_1.default.trackSpan('cli:plugin:start', 'cli:plugin:complete', 'cli:plugin:error', {
                    plugin: name,
                    options,
                }, () => __awaiter(this, void 0, void 0, function* () {
                    let result = run(runnerOptions.schema, options, dmmf, {
                        output: runnerOptions.output,
                        compile: runnerOptions.compile,
                    });
                    if (result instanceof Promise) {
                        result = yield result;
                    }
                    if (Array.isArray(result)) {
                        warnings.push(...result);
                    }
                }));
                spinner.succeed();
            }
            catch (err) {
                spinner.fail();
                throw err;
            }
        });
    }
    getPluginModulePath(provider, options) {
        let pluginModulePath = provider;
        if (provider.startsWith('@core/')) {
            pluginModulePath = provider.replace(/^@core/, path_1.default.join(__dirname, '../plugins'));
        }
        else {
            try {
                // direct require
                require.resolve(pluginModulePath);
            }
            catch (_a) {
                // relative
                pluginModulePath = (0, sdk_1.resolvePath)(provider, options);
            }
        }
        return pluginModulePath;
    }
    loadPluginModule(provider, options) {
        const pluginModulePath = this.getPluginModulePath(provider, options);
        return require(pluginModulePath);
    }
}
exports.PluginRunner = PluginRunner;
//# sourceMappingURL=plugin-runner.js.map