"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZModelScopeProvider = exports.ZModelScopeComputation = void 0;
const ast_1 = require("@zenstackhq/language/ast");
const sdk_1 = require("@zenstackhq/sdk");
const langium_1 = require("langium");
const ast_utils_1 = require("../utils/ast-utils");
const constants_1 = require("./constants");
/**
 * Custom Langium ScopeComputation implementation which adds enum fields into global scope
 */
class ZModelScopeComputation extends langium_1.DefaultScopeComputation {
    constructor(services) {
        super(services);
        this.services = services;
    }
    computeExports(document, cancelToken) {
        const _super = Object.create(null, {
            computeExports: { get: () => super.computeExports }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield _super.computeExports.call(this, document, cancelToken);
            // add enum fields so they can be globally resolved across modules
            for (const node of (0, langium_1.streamAllContents)(document.parseResult.value)) {
                if (cancelToken) {
                    yield (0, langium_1.interruptAndCheck)(cancelToken);
                }
                if ((0, ast_1.isEnumField)(node)) {
                    const desc = this.services.workspace.AstNodeDescriptionProvider.createDescription(node, node.name, document);
                    result.push(desc);
                }
            }
            return result;
        });
    }
    computeLocalScopes(document, cancelToken) {
        const result = super.computeLocalScopes(document, cancelToken);
        //the $resolvedFields would be used in Linking stage for all the documents
        //so we need to set it at the end of the scope computation
        this.resolveBaseModels(document);
        return result;
    }
    resolveBaseModels(document) {
        const model = document.parseResult.value;
        model.declarations.forEach((decl) => {
            if (decl.$type === 'DataModel') {
                const dataModel = decl;
                dataModel.$resolvedFields = [...dataModel.fields];
                this.getRecursiveSuperTypes(dataModel).forEach((superType) => {
                    superType.fields.forEach((field) => {
                        const cloneField = Object.assign({}, field);
                        cloneField.$isInherited = true;
                        const mutable = cloneField;
                        // update container
                        mutable.$container = dataModel;
                        dataModel.$resolvedFields.push(cloneField);
                    });
                });
            }
        });
    }
    getRecursiveSuperTypes(dataModel) {
        const result = [];
        dataModel.superTypes.forEach((superType) => {
            const superTypeDecl = superType.ref;
            if (superTypeDecl) {
                result.push(superTypeDecl);
                result.push(...this.getRecursiveSuperTypes(superTypeDecl));
            }
        });
        return result;
    }
}
exports.ZModelScopeComputation = ZModelScopeComputation;
class ZModelScopeProvider extends langium_1.DefaultScopeProvider {
    constructor(services) {
        super(services);
    }
    getGlobalScope(referenceType, context) {
        const model = (0, langium_1.getContainerOfType)(context.container, ast_1.isModel);
        if (!model) {
            return langium_1.EMPTY_SCOPE;
        }
        const importedUris = (0, langium_1.stream)(model.imports).map(ast_utils_1.resolveImportUri).nonNullable();
        const importedElements = this.indexManager.allElements(referenceType).filter((des) => {
            var _a;
            // allow current document
            return (0, langium_1.equalURI)(des.documentUri, (_a = model.$document) === null || _a === void 0 ? void 0 : _a.uri) ||
                // allow stdlib
                des.documentUri.path.endsWith(constants_1.STD_LIB_MODULE_NAME) ||
                // allow plugin models
                des.documentUri.path.endsWith(constants_1.PLUGIN_MODULE_NAME) ||
                // allow imported documents
                importedUris.some((importedUri) => (des.documentUri, importedUri));
        });
        return new langium_1.StreamScope(importedElements);
    }
    getScope(context) {
        if ((0, ast_1.isMemberAccessExpr)(context.container) && context.container.operand && context.property === 'member') {
            return this.getMemberAccessScope(context.container);
        }
        return super.getScope(context);
    }
    getMemberAccessScope(node) {
        var _a, _b;
        if ((0, ast_1.isReferenceExpr)(node.operand)) {
            // scope to target model's fields
            const ref = node.operand.target.ref;
            if ((0, ast_1.isDataModelField)(ref)) {
                const targetModel = (_a = ref.type.reference) === null || _a === void 0 ? void 0 : _a.ref;
                if ((0, ast_1.isDataModel)(targetModel)) {
                    return this.createScopeForNodes(targetModel.fields);
                }
            }
        }
        else if ((0, ast_1.isMemberAccessExpr)(node.operand)) {
            // scope to target model's fields
            const ref = node.operand.member.ref;
            if ((0, ast_1.isDataModelField)(ref)) {
                const targetModel = (_b = ref.type.reference) === null || _b === void 0 ? void 0 : _b.ref;
                if ((0, ast_1.isDataModel)(targetModel)) {
                    return this.createScopeForNodes(targetModel.fields);
                }
            }
        }
        else if ((0, ast_1.isInvocationExpr)(node.operand)) {
            // deal with member access from `auth()` and `future()
            const funcName = node.operand.function.$refText;
            if (funcName === 'auth') {
                // resolve to `User` or `@@auth` model
                const model = (0, langium_1.getContainerOfType)(node, ast_1.isModel);
                if (model) {
                    const authModel = (0, sdk_1.getAuthModel)((0, sdk_1.getDataModels)(model));
                    if (authModel) {
                        return this.createScopeForNodes(authModel.fields);
                    }
                }
            }
            if (funcName === 'future') {
                const thisModel = (0, langium_1.getContainerOfType)(node, ast_1.isDataModel);
                if (thisModel) {
                    return this.createScopeForNodes(thisModel.fields);
                }
            }
        }
        return langium_1.EMPTY_SCOPE;
    }
}
exports.ZModelScopeProvider = ZModelScopeProvider;
//# sourceMappingURL=zmodel-scope.js.map