"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultPrismaOutputFile = void 0;
const ast_1 = require("@zenstackhq/language/ast");
const ts_pattern_1 = require("ts-pattern");
const runtime_1 = require("@zenstackhq/runtime");
const sdk_1 = require("@zenstackhq/sdk");
const fs_1 = __importDefault(require("fs"));
const promises_1 = require("fs/promises");
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const strip_color_1 = __importDefault(require("strip-color"));
const _1 = require(".");
const utils_1 = require("../../language-server/validator/utils");
const telemetry_1 = __importDefault(require("../../telemetry"));
const exec_utils_1 = require("../../utils/exec-utils");
const pkg_utils_1 = require("../../utils/pkg-utils");
const prisma_builder_1 = require("./prisma-builder");
const MODEL_PASSTHROUGH_ATTR = '@@prisma.passthrough';
const FIELD_PASSTHROUGH_ATTR = '@prisma.passthrough';
/**
 * Generates Prisma schema file
 */
class PrismaSchemaGenerator {
    constructor() {
        this.zModelGenerator = new sdk_1.ZModelCodeGenerator();
        this.PRELUDE = `//////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE                                                                  //
// This file is automatically generated by ZenStack CLI and should not be manually updated. //
//////////////////////////////////////////////////////////////////////////////////////////////

`;
    }
    generate(model, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const warnings = [];
            const prismaVersion = (0, sdk_1.getPrismaVersion)();
            if (prismaVersion && semver_1.default.lt(prismaVersion, runtime_1.PRISMA_MINIMUM_VERSION)) {
                warnings.push(`ZenStack requires Prisma version "${runtime_1.PRISMA_MINIMUM_VERSION}" or higher. Detected version is "${prismaVersion}".`);
            }
            const prisma = new prisma_builder_1.PrismaModel();
            for (const decl of model.declarations) {
                switch (decl.$type) {
                    case ast_1.DataSource:
                        this.generateDataSource(prisma, decl);
                        break;
                    case ast_1.Enum:
                        this.generateEnum(prisma, decl);
                        break;
                    case ast_1.DataModel:
                        this.generateModel(prisma, decl);
                        break;
                    case ast_1.GeneratorDecl:
                        this.generateGenerator(prisma, decl);
                        break;
                }
            }
            const outFile = options.output
                ? (0, sdk_1.resolvePath)(options.output, options)
                : getDefaultPrismaOutputFile(options.schemaPath);
            if (!fs_1.default.existsSync(path_1.default.dirname(outFile))) {
                fs_1.default.mkdirSync(path_1.default.dirname(outFile), { recursive: true });
            }
            yield (0, promises_1.writeFile)(outFile, this.PRELUDE + prisma.toString());
            if (options.format === true) {
                try {
                    // run 'prisma format'
                    yield (0, exec_utils_1.execPackage)(`prisma format --schema ${outFile}`);
                }
                catch (_a) {
                    warnings.push(`Failed to format Prisma schema file`);
                }
            }
            const generateClient = options.generateClient !== false;
            if (generateClient) {
                let generateCmd = `prisma generate --schema "${outFile}"`;
                if (typeof options.generateArgs === 'string') {
                    generateCmd += ` ${options.generateArgs}`;
                }
                try {
                    // run 'prisma generate'
                    yield (0, exec_utils_1.execPackage)(generateCmd, 'ignore');
                }
                catch (_b) {
                    yield this.trackPrismaSchemaError(outFile);
                    try {
                        // run 'prisma generate' again with output to the console
                        yield (0, exec_utils_1.execPackage)(generateCmd);
                    }
                    catch (_c) {
                        // noop
                    }
                    throw new sdk_1.PluginError(_1.name, `Failed to run "prisma generate"`);
                }
            }
            return warnings;
        });
    }
    trackPrismaSchemaError(schema) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield (0, sdk_1.getDMMF)({ datamodel: fs_1.default.readFileSync(schema, 'utf-8') });
            }
            catch (err) {
                if (err instanceof Error) {
                    // eslint-disable-next-line @typescript-eslint/no-var-requires
                    telemetry_1.default.track('prisma:error', { command: 'generate', message: (0, strip_color_1.default)(err.message) });
                }
            }
        });
    }
    generateDataSource(prisma, dataSource) {
        const fields = dataSource.fields.map((f) => ({
            name: f.name,
            text: this.configExprToText(f.value),
        }));
        prisma.addDataSource(dataSource.name, fields);
    }
    configExprToText(expr) {
        if ((0, ast_1.isLiteralExpr)(expr)) {
            return this.literalToText(expr);
        }
        else if ((0, ast_1.isInvocationExpr)(expr)) {
            const fc = this.makeFunctionCall(expr);
            return fc.toString();
        }
        else {
            return this.configArrayToText(expr);
        }
    }
    configArrayToText(expr) {
        return ('[' +
            expr.items
                .map((item) => {
                if ((0, ast_1.isLiteralExpr)(item)) {
                    return this.literalToText(item);
                }
                else {
                    return (item.name +
                        (item.args.length > 0
                            ? '(' + item.args.map((arg) => this.configInvocationArgToText(arg)).join(', ') + ')'
                            : ''));
                }
            })
                .join(', ') +
            ']');
    }
    configInvocationArgToText(arg) {
        return `${arg.name}: ${this.literalToText(arg.value)}`;
    }
    literalToText(expr) {
        return JSON.stringify(expr.value);
    }
    exprToText(expr) {
        return new sdk_1.ZModelCodeGenerator({ quote: 'double' }).generate(expr);
    }
    generateGenerator(prisma, decl) {
        var _a, _b;
        const generator = prisma.addGenerator(decl.name, decl.fields.map((f) => ({ name: f.name, text: this.configExprToText(f.value) })));
        // deal with configuring PrismaClient preview features
        const provider = generator.fields.find((f) => f.name === 'provider');
        if ((provider === null || provider === void 0 ? void 0 : provider.text) === JSON.stringify('prisma-client-js')) {
            const prismaVersion = (0, sdk_1.getPrismaVersion)();
            if (prismaVersion) {
                const previewFeatures = JSON.parse((_b = (_a = generator.fields.find((f) => f.name === 'previewFeatures')) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : '[]');
                if (!Array.isArray(previewFeatures)) {
                    throw new sdk_1.PluginError(_1.name, 'option "previewFeatures" must be an array');
                }
                if (semver_1.default.lt(prismaVersion, '5.0.0')) {
                    // extendedWhereUnique feature is opt-in pre V5
                    if (!previewFeatures.includes('extendedWhereUnique')) {
                        previewFeatures.push('extendedWhereUnique');
                    }
                }
                if (semver_1.default.lt(prismaVersion, '5.0.0')) {
                    // fieldReference feature is opt-in pre V5
                    if (!previewFeatures.includes('fieldReference')) {
                        previewFeatures.push('fieldReference');
                    }
                }
                if (previewFeatures.length > 0) {
                    const curr = generator.fields.find((f) => f.name === 'previewFeatures');
                    if (!curr) {
                        generator.fields.push({ name: 'previewFeatures', text: JSON.stringify(previewFeatures) });
                    }
                    else {
                        curr.text = JSON.stringify(previewFeatures);
                    }
                }
            }
        }
    }
    generateModel(prisma, decl) {
        const model = decl.isView ? prisma.addView(decl.name) : prisma.addModel(decl.name);
        for (const field of decl.fields) {
            this.generateModelField(model, field);
        }
        for (const attr of decl.attributes.filter((attr) => this.isPrismaAttribute(attr))) {
            this.generateContainerAttribute(model, attr);
        }
        decl.attributes
            .filter((attr) => attr.decl.ref && !this.isPrismaAttribute(attr))
            .forEach((attr) => model.addComment('/// ' + this.zModelGenerator.generate(attr)));
        // user defined comments pass-through
        decl.comments.forEach((c) => model.addComment(c));
    }
    isPrismaAttribute(attr) {
        if (!attr.decl.ref) {
            return false;
        }
        const attrDecl = (0, sdk_1.resolved)(attr.decl);
        return (!!attrDecl.attributes.find((a) => { var _a; return ((_a = a.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@@@prisma'; }) ||
            // the special pass-through attribute
            attrDecl.name === MODEL_PASSTHROUGH_ATTR ||
            attrDecl.name === FIELD_PASSTHROUGH_ATTR);
    }
    getUnsupportedFieldType(fieldType) {
        if (fieldType.unsupported) {
            const value = (0, utils_1.getStringLiteral)(fieldType.unsupported.value);
            if (value) {
                return `Unsupported("${value}")`;
            }
            else {
                return undefined;
            }
        }
        else {
            return undefined;
        }
    }
    generateModelField(model, field) {
        var _a, _b;
        const fieldType = field.type.type || ((_b = (_a = field.type.reference) === null || _a === void 0 ? void 0 : _a.ref) === null || _b === void 0 ? void 0 : _b.name) || this.getUnsupportedFieldType(field.type);
        if (!fieldType) {
            throw new sdk_1.PluginError(_1.name, `Field type is not resolved: ${field.$container.name}.${field.name}`);
        }
        const type = new prisma_builder_1.ModelFieldType(fieldType, field.type.array, field.type.optional);
        const attributes = field.attributes
            .filter((attr) => this.isPrismaAttribute(attr))
            .map((attr) => this.makeFieldAttribute(attr));
        const nonPrismaAttributes = field.attributes.filter((attr) => attr.decl.ref && !this.isPrismaAttribute(attr));
        const documentations = nonPrismaAttributes.map((attr) => '/// ' + this.zModelGenerator.generate(attr));
        const result = model.addField(field.name, type, attributes, documentations);
        // user defined comments pass-through
        field.comments.forEach((c) => result.addComment(c));
    }
    makeFieldAttribute(attr) {
        const attrName = (0, sdk_1.resolved)(attr.decl).name;
        if (attrName === FIELD_PASSTHROUGH_ATTR) {
            const text = (0, sdk_1.getLiteral)(attr.args[0].value);
            if (text) {
                return new prisma_builder_1.PassThroughAttribute(text);
            }
            else {
                throw new sdk_1.PluginError(_1.name, `Invalid arguments for ${FIELD_PASSTHROUGH_ATTR} attribute`);
            }
        }
        else {
            return new prisma_builder_1.FieldAttribute(attrName, attr.args.map((arg) => this.makeAttributeArg(arg)));
        }
    }
    makeAttributeArg(arg) {
        return new prisma_builder_1.AttributeArg(arg.name, this.makeAttributeArgValue(arg.value));
    }
    makeAttributeArgValue(node) {
        if ((0, ast_1.isLiteralExpr)(node)) {
            const argType = (0, ts_pattern_1.match)(node.$type)
                .with(ast_1.StringLiteral, () => 'String')
                .with(ast_1.NumberLiteral, () => 'Number')
                .with(ast_1.BooleanLiteral, () => 'Boolean')
                .exhaustive();
            return new prisma_builder_1.AttributeArgValue(argType, node.value);
        }
        else if ((0, ast_1.isArrayExpr)(node)) {
            return new prisma_builder_1.AttributeArgValue('Array', new Array(...node.items.map((item) => this.makeAttributeArgValue(item))));
        }
        else if ((0, ast_1.isReferenceExpr)(node)) {
            return new prisma_builder_1.AttributeArgValue('FieldReference', new prisma_builder_1.FieldReference((0, sdk_1.resolved)(node.target).name, node.args.map((arg) => new prisma_builder_1.FieldReferenceArg(arg.name, this.exprToText(arg.value)))));
        }
        else if ((0, ast_1.isInvocationExpr)(node)) {
            // invocation
            return new prisma_builder_1.AttributeArgValue('FunctionCall', this.makeFunctionCall(node));
        }
        else {
            throw new sdk_1.PluginError(_1.name, `Unsupported attribute argument expression type: ${node.$type}`);
        }
    }
    makeFunctionCall(node) {
        return new prisma_builder_1.FunctionCall((0, sdk_1.resolved)(node.function).name, node.args.map((arg) => {
            const val = (0, ts_pattern_1.match)(arg.value)
                .when(ast_1.isStringLiteral, (v) => `"${v.value}"`)
                .when(ast_1.isLiteralExpr, (v) => v.value.toString())
                .when(ast_1.isNullExpr, () => 'null')
                .otherwise(() => {
                throw new sdk_1.PluginError(_1.name, 'Function call argument must be literal or null');
            });
            return new prisma_builder_1.FunctionCallArg(val);
        }));
    }
    generateContainerAttribute(container, attr) {
        const attrName = (0, sdk_1.resolved)(attr.decl).name;
        if (attrName === MODEL_PASSTHROUGH_ATTR) {
            const text = (0, sdk_1.getLiteral)(attr.args[0].value);
            if (text) {
                container.attributes.push(new prisma_builder_1.PassThroughAttribute(text));
            }
        }
        else {
            container.attributes.push(new prisma_builder_1.ContainerAttribute(attrName, attr.args.map((arg) => this.makeAttributeArg(arg))));
        }
    }
    generateEnum(prisma, decl) {
        const _enum = prisma.addEnum(decl.name);
        for (const field of decl.fields) {
            this.generateEnumField(_enum, field);
        }
        for (const attr of decl.attributes.filter((attr) => this.isPrismaAttribute(attr))) {
            this.generateContainerAttribute(_enum, attr);
        }
        decl.attributes
            .filter((attr) => attr.decl.ref && !this.isPrismaAttribute(attr))
            .forEach((attr) => _enum.addComment('/// ' + this.zModelGenerator.generate(attr)));
        // user defined comments pass-through
        decl.comments.forEach((c) => _enum.addComment(c));
    }
    generateEnumField(_enum, field) {
        const attributes = field.attributes
            .filter((attr) => this.isPrismaAttribute(attr))
            .map((attr) => this.makeFieldAttribute(attr));
        const nonPrismaAttributes = field.attributes.filter((attr) => attr.decl.ref && !this.isPrismaAttribute(attr));
        const documentations = nonPrismaAttributes.map((attr) => '/// ' + this.zModelGenerator.generate(attr));
        _enum.addField(field.name, attributes, documentations);
    }
}
exports.default = PrismaSchemaGenerator;
function getDefaultPrismaOutputFile(schemaPath) {
    var _a;
    // handle override from package.json
    const pkgJsonPath = (0, pkg_utils_1.findUp)(['package.json'], path_1.default.dirname(schemaPath));
    if (pkgJsonPath) {
        const pkgJson = JSON.parse(fs_1.default.readFileSync(pkgJsonPath, 'utf-8'));
        if (typeof ((_a = pkgJson === null || pkgJson === void 0 ? void 0 : pkgJson.zenstack) === null || _a === void 0 ? void 0 : _a.prisma) === 'string') {
            if (path_1.default.isAbsolute(pkgJson.zenstack.prisma)) {
                return pkgJson.zenstack.prisma;
            }
            else {
                // resolve relative to package.json
                return path_1.default.resolve(path_1.default.dirname(pkgJsonPath), pkgJson.zenstack.prisma);
            }
        }
    }
    return (0, sdk_1.resolvePath)('./prisma/schema.prisma', { schemaPath });
}
exports.getDefaultPrismaOutputFile = getDefaultPrismaOutputFile;
//# sourceMappingURL=schema-generator.js.map