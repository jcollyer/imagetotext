"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
const sdk_1 = require("@zenstackhq/sdk");
const ast_1 = require("@zenstackhq/sdk/ast");
const dmmf_helpers_1 = require("@zenstackhq/sdk/dmmf-helpers");
const fs_1 = require("fs");
const langium_1 = require("langium");
const path_1 = __importDefault(require("path"));
const upper_case_first_1 = require("upper-case-first");
const _1 = require(".");
const plugin_utils_1 = require("../plugin-utils");
const transformer_1 = __importDefault(require("./transformer"));
const removeDir_1 = __importDefault(require("./utils/removeDir"));
const schema_gen_1 = require("./utils/schema-gen");
function generate(model, options, dmmf, globalOptions) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        let output = options.output;
        if (!output) {
            const defaultOutputFolder = (0, plugin_utils_1.getDefaultOutputFolder)(globalOptions);
            if (defaultOutputFolder) {
                output = path_1.default.join(defaultOutputFolder, 'zod');
            }
            else {
                output = './generated/zod';
            }
        }
        output = (0, sdk_1.resolvePath)(output, options);
        yield handleGeneratorOutputValue(output);
        // calculate the models to be excluded
        const excludeModels = getExcludedModels(model, options);
        const prismaClientDmmf = dmmf;
        const modelOperations = prismaClientDmmf.mappings.modelOperations.filter((o) => !excludeModels.find((e) => e === o.model));
        // TODO: better way of filtering than string startsWith?
        const inputObjectTypes = prismaClientDmmf.schema.inputObjectTypes.prisma.filter((type) => !excludeModels.find((e) => type.name.toLowerCase().startsWith(e.toLocaleLowerCase())));
        const outputObjectTypes = prismaClientDmmf.schema.outputObjectTypes.prisma.filter((type) => !excludeModels.find((e) => type.name.toLowerCase().startsWith(e.toLowerCase())));
        const models = prismaClientDmmf.datamodel.models.filter((m) => !excludeModels.find((e) => e === m.name));
        // whether Prisma's Unchecked* series of input types should be generated
        const generateUnchecked = options.noUncheckedInput !== true;
        const project = (0, sdk_1.createProject)();
        // common schemas
        yield generateCommonSchemas(project, output);
        // enums
        yield generateEnumSchemas(prismaClientDmmf.schema.enumTypes.prisma, (_a = prismaClientDmmf.schema.enumTypes.model) !== null && _a !== void 0 ? _a : [], project, model);
        const dataSource = model.declarations.find((d) => (0, ast_1.isDataSource)(d));
        const dataSourceProvider = (0, sdk_1.getLiteral)((_b = dataSource === null || dataSource === void 0 ? void 0 : dataSource.fields.find((f) => f.name === 'provider')) === null || _b === void 0 ? void 0 : _b.value);
        yield generateModelSchemas(project, model, output, excludeModels);
        if (options.modelOnly !== true) {
            // detailed object schemas referenced from input schemas
            transformer_1.default.provider = dataSourceProvider;
            (0, dmmf_helpers_1.addMissingInputObjectTypes)(inputObjectTypes, outputObjectTypes, models);
            const aggregateOperationSupport = (0, dmmf_helpers_1.resolveAggregateOperationSupport)(inputObjectTypes);
            yield generateObjectSchemas(inputObjectTypes, project, output, model, generateUnchecked);
            // input schemas
            const transformer = new transformer_1.default({
                models,
                modelOperations,
                aggregateOperationSupport,
                project,
                zmodel: model,
                inputObjectTypes,
            });
            yield transformer.generateInputSchemas(generateUnchecked);
        }
        // create barrel file
        const exports = [`export * as models from './models'`, `export * as enums from './enums'`];
        if (options.modelOnly !== true) {
            exports.push(`export * as input from './input'`, `export * as objects from './objects'`);
        }
        project.createSourceFile(path_1.default.join(output, 'index.ts'), exports.join(';\n'), { overwrite: true });
        // emit
        let shouldCompile = true;
        if (typeof options.compile === 'boolean') {
            // explicit override
            shouldCompile = options.compile;
        }
        else if (globalOptions) {
            // from CLI or config file
            shouldCompile = globalOptions.compile;
        }
        if (!shouldCompile || options.preserveTsFiles === true) {
            // save ts files
            yield (0, sdk_1.saveProject)(project);
        }
        if (shouldCompile) {
            yield (0, sdk_1.emitProject)(project);
        }
    });
}
exports.generate = generate;
function getExcludedModels(model, options) {
    // resolve "generateModels" option
    const generateModels = (0, sdk_1.parseOptionAsStrings)(options, 'generateModels', _1.name);
    if (generateModels) {
        if (options.modelOnly === true) {
            // no model reference needs to be considered, directly exclude any model not included
            return model.declarations
                .filter((d) => (0, ast_1.isDataModel)(d) && !generateModels.includes(d.name))
                .map((m) => m.name);
        }
        else {
            // calculate a transitive closure of models to be included
            const todo = (0, sdk_1.getDataModels)(model).filter((dm) => generateModels.includes(dm.name));
            const included = new Set();
            while (todo.length > 0) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const dm = todo.pop();
                included.add(dm);
                // add referenced models to the todo list
                dm.fields
                    .map((f) => { var _a; return (_a = f.type.reference) === null || _a === void 0 ? void 0 : _a.ref; })
                    .filter((type) => (0, ast_1.isDataModel)(type))
                    .forEach((type) => {
                    if (!included.has(type)) {
                        todo.push(type);
                    }
                });
            }
            // finally find the models to be excluded
            return (0, sdk_1.getDataModels)(model)
                .filter((dm) => !included.has(dm))
                .map((m) => m.name);
        }
    }
    else {
        return [];
    }
}
function handleGeneratorOutputValue(output) {
    return __awaiter(this, void 0, void 0, function* () {
        // create the output directory and delete contents that might exist from a previous run
        yield fs_1.promises.mkdir(output, { recursive: true });
        const isRemoveContentsOnly = true;
        yield (0, removeDir_1.default)(output, isRemoveContentsOnly);
        transformer_1.default.setOutputPath(output);
    });
}
function generateCommonSchemas(project, output) {
    return __awaiter(this, void 0, void 0, function* () {
        // Decimal
        project.createSourceFile(path_1.default.join(output, 'common', 'index.ts'), `
import { z } from 'zod';
export const DecimalSchema = z.union([z.number(), z.string(), z.object({d: z.number().array(), e: z.number(), s: z.number()}).passthrough()]);
`, { overwrite: true });
    });
}
function generateEnumSchemas(prismaSchemaEnum, modelSchemaEnum, project, zmodel) {
    return __awaiter(this, void 0, void 0, function* () {
        const enumTypes = [...prismaSchemaEnum, ...modelSchemaEnum];
        const enumNames = enumTypes.map((enumItem) => (0, upper_case_first_1.upperCaseFirst)(enumItem.name));
        transformer_1.default.enumNames = enumNames !== null && enumNames !== void 0 ? enumNames : [];
        const transformer = new transformer_1.default({
            enumTypes,
            project,
            zmodel,
            inputObjectTypes: [],
        });
        yield transformer.generateEnumSchemas();
    });
}
function generateObjectSchemas(inputObjectTypes, project, output, zmodel, generateUnchecked) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const moduleNames = [];
        for (let i = 0; i < inputObjectTypes.length; i += 1) {
            const fields = (_a = inputObjectTypes[i]) === null || _a === void 0 ? void 0 : _a.fields;
            const name = (_b = inputObjectTypes[i]) === null || _b === void 0 ? void 0 : _b.name;
            if (!generateUnchecked && name.includes('Unchecked')) {
                continue;
            }
            const transformer = new transformer_1.default({ name, fields, project, zmodel, inputObjectTypes });
            const moduleName = transformer.generateObjectSchema(generateUnchecked);
            moduleNames.push(moduleName);
        }
        project.createSourceFile(path_1.default.join(output, 'objects/index.ts'), moduleNames.map((name) => `export * from './${name}';`).join('\n'), { overwrite: true });
    });
}
function generateModelSchemas(project, zmodel, output, excludedModels) {
    return __awaiter(this, void 0, void 0, function* () {
        const schemaNames = [];
        for (const dm of (0, sdk_1.getDataModels)(zmodel)) {
            if (!excludedModels.includes(dm.name)) {
                schemaNames.push(yield generateModelSchema(dm, project, output));
            }
        }
        project.createSourceFile(path_1.default.join(output, 'models', 'index.ts'), schemaNames.map((name) => `export * from './${name}';`).join('\n'), { overwrite: true });
    });
}
function generateModelSchema(model, project, output) {
    return __awaiter(this, void 0, void 0, function* () {
        const schemaName = `${(0, upper_case_first_1.upperCaseFirst)(model.name)}.schema`;
        const sf = project.createSourceFile(path_1.default.join(output, 'models', `${schemaName}.ts`), undefined, {
            overwrite: true,
        });
        sf.replaceWithText((writer) => {
            var _a, _b, _c;
            const scalarFields = model.fields.filter((field) => { var _a; 
            // regular fields only
            return !(0, ast_1.isDataModel)((_a = field.type.reference) === null || _a === void 0 ? void 0 : _a.ref) && !(0, sdk_1.isForeignKeyField)(field); });
            const relations = model.fields.filter((field) => { var _a; return (0, ast_1.isDataModel)((_a = field.type.reference) === null || _a === void 0 ? void 0 : _a.ref); });
            const fkFields = model.fields.filter((field) => (0, sdk_1.isForeignKeyField)(field));
            writer.writeLine('/* eslint-disable */');
            writer.writeLine(`import { z } from 'zod';`);
            // import user-defined enums from Prisma as they might be referenced in the expressions
            const importEnums = new Set();
            for (const node of (0, langium_1.streamAllContents)(model)) {
                if ((0, sdk_1.isEnumFieldReference)(node)) {
                    const field = node.target.ref;
                    if (!(0, sdk_1.isFromStdlib)(field.$container)) {
                        importEnums.add(field.$container.name);
                    }
                }
            }
            if (importEnums.size > 0) {
                const prismaImport = (0, sdk_1.getPrismaClientImportSpec)(model.$container, path_1.default.join(output, 'models'));
                writer.writeLine(`import { ${[...importEnums].join(', ')} } from '${prismaImport}';`);
            }
            // import enum schemas
            const importedEnumSchemas = new Set();
            for (const field of scalarFields) {
                if (((_a = field.type.reference) === null || _a === void 0 ? void 0 : _a.ref) && (0, ast_1.isEnum)((_b = field.type.reference) === null || _b === void 0 ? void 0 : _b.ref)) {
                    const name = (0, upper_case_first_1.upperCaseFirst)((_c = field.type.reference) === null || _c === void 0 ? void 0 : _c.ref.name);
                    if (!importedEnumSchemas.has(name)) {
                        writer.writeLine(`import { ${name}Schema } from '../enums/${name}.schema';`);
                        importedEnumSchemas.add(name);
                    }
                }
            }
            // import Decimal
            if (scalarFields.some((field) => field.type.type === 'Decimal')) {
                writer.writeLine(`import { DecimalSchema } from '../common';`);
                writer.writeLine(`import { Decimal } from 'decimal.js';`);
            }
            // base schema
            writer.write(`const baseSchema = z.object(`);
            writer.inlineBlock(() => {
                scalarFields.forEach((field) => {
                    writer.writeLine(`${field.name}: ${(0, schema_gen_1.makeFieldSchema)(field, true)},`);
                });
            });
            writer.writeLine(');');
            // relation fields
            let relationSchema;
            let fkSchema;
            if (relations.length > 0 || fkFields.length > 0) {
                relationSchema = 'relationSchema';
                writer.write(`const ${relationSchema} = z.object(`);
                writer.inlineBlock(() => {
                    [...relations, ...fkFields].forEach((field) => {
                        writer.writeLine(`${field.name}: ${(0, schema_gen_1.makeFieldSchema)(field)},`);
                    });
                });
                writer.writeLine(');');
            }
            if (fkFields.length > 0) {
                fkSchema = 'fkSchema';
                writer.write(`const ${fkSchema} = z.object(`);
                writer.inlineBlock(() => {
                    fkFields.forEach((field) => {
                        writer.writeLine(`${field.name}: ${(0, schema_gen_1.makeFieldSchema)(field)},`);
                    });
                });
                writer.writeLine(');');
            }
            // compile "@@validate" to ".refine"
            const refinements = (0, schema_gen_1.makeValidationRefinements)(model);
            let refineFuncName;
            if (refinements.length > 0) {
                refineFuncName = `refine${(0, upper_case_first_1.upperCaseFirst)(model.name)}`;
                writer.writeLine(`export function ${refineFuncName}<T, D extends z.ZodTypeDef>(schema: z.ZodType<T, D, T>) { return schema${refinements.join('\n')}; }`);
            }
            ////////////////////////////////////////////////
            // 1. Model schema
            ////////////////////////////////////////////////
            const fieldsWithoutDefault = scalarFields.filter((f) => !(0, schema_gen_1.getFieldSchemaDefault)(f));
            // mark fields without default value as optional
            let modelSchema = makePartial('baseSchema', fieldsWithoutDefault.length < scalarFields.length ? fieldsWithoutDefault.map((f) => f.name) : undefined);
            // omit fields
            const fieldsToOmit = scalarFields.filter((field) => (0, sdk_1.hasAttribute)(field, '@omit'));
            if (fieldsToOmit.length > 0) {
                modelSchema = makeOmit(modelSchema, fieldsToOmit.map((f) => f.name));
            }
            if (relationSchema) {
                // export schema with only scalar fields
                const modelScalarSchema = `${(0, upper_case_first_1.upperCaseFirst)(model.name)}ScalarSchema`;
                writer.writeLine(`export const ${modelScalarSchema} = ${modelSchema};`);
                modelSchema = modelScalarSchema;
                // merge relations
                modelSchema = makeMerge(modelSchema, makePartial(relationSchema));
            }
            // refine
            if (refineFuncName) {
                const noRefineSchema = `${(0, upper_case_first_1.upperCaseFirst)(model.name)}WithoutRefineSchema`;
                writer.writeLine(`export const ${noRefineSchema} = ${modelSchema};`);
                modelSchema = `${refineFuncName}(${noRefineSchema})`;
            }
            writer.writeLine(`export const ${(0, upper_case_first_1.upperCaseFirst)(model.name)}Schema = ${modelSchema};`);
            ////////////////////////////////////////////////
            // 2. Prisma create & update
            ////////////////////////////////////////////////
            // schema for validating prisma create input (all fields optional)
            let prismaCreateSchema = makePassthrough(makePartial('baseSchema'));
            if (refineFuncName) {
                prismaCreateSchema = `${refineFuncName}(${prismaCreateSchema})`;
            }
            writer.writeLine(`export const ${(0, upper_case_first_1.upperCaseFirst)(model.name)}PrismaCreateSchema = ${prismaCreateSchema};`);
            // schema for validating prisma update input (all fields optional)
            // note numeric fields can be simple update or atomic operations
            let prismaUpdateSchema = `z.object({
            ${scalarFields
                .map((field) => {
                let fieldSchema = (0, schema_gen_1.makeFieldSchema)(field);
                if (field.type.type === 'Int' || field.type.type === 'Float') {
                    fieldSchema = `z.union([${fieldSchema}, z.record(z.unknown())])`;
                }
                return `\t${field.name}: ${fieldSchema}`;
            })
                .join(',\n')}
})`;
            prismaUpdateSchema = makePartial(prismaUpdateSchema);
            if (refineFuncName) {
                prismaUpdateSchema = `${refineFuncName}(${prismaUpdateSchema})`;
            }
            writer.writeLine(`export const ${(0, upper_case_first_1.upperCaseFirst)(model.name)}PrismaUpdateSchema = ${prismaUpdateSchema};`);
            ////////////////////////////////////////////////
            // 3. Create schema
            ////////////////////////////////////////////////
            let createSchema = 'baseSchema';
            const fieldsWithDefault = scalarFields.filter((field) => (0, sdk_1.hasAttribute)(field, '@default') || (0, sdk_1.hasAttribute)(field, '@updatedAt') || field.type.array);
            if (fieldsWithDefault.length > 0) {
                createSchema = makePartial(createSchema, fieldsWithDefault.map((f) => f.name));
            }
            if (fkSchema) {
                // export schema with only scalar fields
                const createScalarSchema = `${(0, upper_case_first_1.upperCaseFirst)(model.name)}CreateScalarSchema`;
                writer.writeLine(`export const ${createScalarSchema} = ${createSchema};`);
                // merge fk fields
                createSchema = makeMerge(createScalarSchema, fkSchema);
            }
            if (refineFuncName) {
                // export a schema without refinement for extensibility
                const noRefineSchema = `${(0, upper_case_first_1.upperCaseFirst)(model.name)}CreateWithoutRefineSchema`;
                writer.writeLine(`export const ${noRefineSchema} = ${createSchema};`);
                createSchema = `${refineFuncName}(${noRefineSchema})`;
            }
            writer.writeLine(`export const ${(0, upper_case_first_1.upperCaseFirst)(model.name)}CreateSchema = ${createSchema};`);
            ////////////////////////////////////////////////
            // 3. Update schema
            ////////////////////////////////////////////////
            let updateSchema = makePartial('baseSchema');
            if (fkSchema) {
                // export schema with only scalar fields
                const updateScalarSchema = `${(0, upper_case_first_1.upperCaseFirst)(model.name)}UpdateScalarSchema`;
                writer.writeLine(`export const ${updateScalarSchema} = ${updateSchema};`);
                updateSchema = updateScalarSchema;
                // merge fk fields
                updateSchema = makeMerge(updateSchema, makePartial(fkSchema));
            }
            if (refineFuncName) {
                // export a schema without refinement for extensibility
                const noRefineSchema = `${(0, upper_case_first_1.upperCaseFirst)(model.name)}UpdateWithoutRefineSchema`;
                writer.writeLine(`export const ${noRefineSchema} = ${updateSchema};`);
                updateSchema = `${refineFuncName}(${noRefineSchema})`;
            }
            writer.writeLine(`export const ${(0, upper_case_first_1.upperCaseFirst)(model.name)}UpdateSchema = ${updateSchema};`);
        });
        return schemaName;
    });
}
function makePartial(schema, fields) {
    if (fields) {
        if (fields.length === 0) {
            return schema;
        }
        else {
            return `${schema}.partial({
        ${fields.map((f) => `${f}: true`).join(', ')}
    })`;
        }
    }
    else {
        return `${schema}.partial()`;
    }
}
function makeOmit(schema, fields) {
    return `${schema}.omit({
        ${fields.map((f) => `${f}: true`).join(', ')},
    })`;
}
function makeMerge(schema1, schema2) {
    return `${schema1}.merge(${schema2})`;
}
function makePassthrough(schema) {
    return `${schema}.passthrough()`;
}
//# sourceMappingURL=generator.js.map