"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findUpAst = exports.getContainingDataModel = exports.isCollectionPredicate = exports.getAllDeclarationsFromImports = exports.resolveImport = exports.resolveTransitiveImports = exports.resolveImportUri = exports.getDataModelFieldReference = exports.isAuthInvocation = exports.getIdFields = exports.mergeBaseModel = exports.extractDataModelsWithAllowRules = void 0;
const ast_1 = require("@zenstackhq/language/ast");
const sdk_1 = require("@zenstackhq/sdk");
const langium_1 = require("langium");
const vscode_uri_1 = require("vscode-uri");
const pkg_utils_1 = require("./pkg-utils");
const node_path_1 = require("node:path");
function extractDataModelsWithAllowRules(model) {
    return model.declarations.filter((d) => (0, ast_1.isDataModel)(d) && d.attributes.some((attr) => { var _a; return ((_a = attr.decl.ref) === null || _a === void 0 ? void 0 : _a.name) === '@@allow'; }));
}
exports.extractDataModelsWithAllowRules = extractDataModelsWithAllowRules;
function mergeBaseModel(model) {
    model.declarations
        .filter((x) => x.$type === 'DataModel')
        .forEach((decl) => {
        const dataModel = decl;
        dataModel.fields = dataModel.superTypes
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            .flatMap((superType) => updateContainer(superType.ref.fields, dataModel))
            .concat(dataModel.fields);
        dataModel.attributes = dataModel.superTypes
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            .flatMap((superType) => updateContainer(superType.ref.attributes, dataModel))
            .concat(dataModel.attributes);
    });
    // remove abstract models
    model.declarations = model.declarations.filter((x) => !(x.$type == 'DataModel' && x.isAbstract));
}
exports.mergeBaseModel = mergeBaseModel;
function updateContainer(nodes, container) {
    return nodes.map((node) => {
        const cloneField = Object.assign({}, node);
        const mutable = cloneField;
        // update container
        mutable.$container = container;
        return mutable;
    });
}
function getIdFields(dataModel) {
    const fieldLevelId = dataModel.$resolvedFields.find((f) => f.attributes.some((attr) => attr.decl.$refText === '@id'));
    if (fieldLevelId) {
        return [fieldLevelId];
    }
    else {
        // get model level @@id attribute
        const modelIdAttr = dataModel.attributes.find((attr) => { var _a, _b; return ((_b = (_a = attr.decl) === null || _a === void 0 ? void 0 : _a.ref) === null || _b === void 0 ? void 0 : _b.name) === '@@id'; });
        if (modelIdAttr) {
            // get fields referenced in the attribute: @@id([field1, field2]])
            if (!(0, ast_1.isArrayExpr)(modelIdAttr.args[0].value)) {
                return [];
            }
            const argValue = modelIdAttr.args[0].value;
            return argValue.items
                .filter((expr) => (0, ast_1.isReferenceExpr)(expr) && !!getDataModelFieldReference(expr))
                .map((expr) => expr.target.ref);
        }
    }
    return [];
}
exports.getIdFields = getIdFields;
function isAuthInvocation(node) {
    var _a;
    return (0, ast_1.isInvocationExpr)(node) && ((_a = node.function.ref) === null || _a === void 0 ? void 0 : _a.name) === 'auth' && (0, sdk_1.isFromStdlib)(node.function.ref);
}
exports.isAuthInvocation = isAuthInvocation;
function getDataModelFieldReference(expr) {
    if ((0, ast_1.isReferenceExpr)(expr) && (0, ast_1.isDataModelField)(expr.target.ref)) {
        return expr.target.ref;
    }
    else if ((0, ast_1.isMemberAccessExpr)(expr) && (0, ast_1.isDataModelField)(expr.member.ref)) {
        return expr.member.ref;
    }
    else {
        return undefined;
    }
}
exports.getDataModelFieldReference = getDataModelFieldReference;
function resolveImportUri(imp) {
    var _a;
    if (!imp.path)
        return undefined; // This will return true if imp.path is undefined, null, or an empty string ("").
    if (!imp.path.endsWith('.zmodel')) {
        imp.path += '.zmodel';
    }
    if (!imp.path.startsWith('.') // Respect relative paths
        && !(0, node_path_1.isAbsolute)(imp.path) // Respect Absolute paths
    ) {
        imp.path = (_a = (0, pkg_utils_1.findNodeModulesFile)(imp.path)) !== null && _a !== void 0 ? _a : imp.path;
    }
    const dirUri = vscode_uri_1.Utils.dirname((0, langium_1.getDocument)(imp).uri);
    return vscode_uri_1.Utils.resolvePath(dirUri, imp.path);
}
exports.resolveImportUri = resolveImportUri;
function resolveTransitiveImports(documents, model) {
    return resolveTransitiveImportsInternal(documents, model);
}
exports.resolveTransitiveImports = resolveTransitiveImports;
function resolveTransitiveImportsInternal(documents, model, initialModel = model, visited = new Set(), models = new Set()) {
    const doc = (0, langium_1.getDocument)(model);
    if (initialModel !== model) {
        models.add(model);
    }
    if (!visited.has(doc.uri)) {
        visited.add(doc.uri);
        for (const imp of model.imports) {
            const importedModel = resolveImport(documents, imp);
            if (importedModel) {
                resolveTransitiveImportsInternal(documents, importedModel, initialModel, visited, models);
            }
        }
    }
    return Array.from(models);
}
function resolveImport(documents, imp) {
    const resolvedUri = resolveImportUri(imp);
    try {
        if (resolvedUri) {
            const resolvedDocument = documents.getOrCreateDocument(resolvedUri);
            const node = resolvedDocument.parseResult.value;
            if ((0, ast_1.isModel)(node)) {
                return node;
            }
        }
    }
    catch (_a) {
        // NOOP
    }
    return undefined;
}
exports.resolveImport = resolveImport;
function getAllDeclarationsFromImports(documents, model) {
    const imports = resolveTransitiveImports(documents, model);
    return model.declarations.concat(...imports.map((imp) => imp.declarations));
}
exports.getAllDeclarationsFromImports = getAllDeclarationsFromImports;
function isCollectionPredicate(node) {
    return (0, ast_1.isBinaryExpr)(node) && ['?', '!', '^'].includes(node.operator);
}
exports.isCollectionPredicate = isCollectionPredicate;
function getContainingDataModel(node) {
    let curr = node.$container;
    while (curr) {
        if ((0, ast_1.isDataModel)(curr)) {
            return curr;
        }
        curr = curr.$container;
    }
    return undefined;
}
exports.getContainingDataModel = getContainingDataModel;
/**
 * Walk upward from the current AST node to find the first node that satisfies the predicate.
 */
function findUpAst(node, predicate) {
    let curr = node;
    while (curr) {
        if (predicate(curr)) {
            return curr;
        }
        curr = curr.$container;
    }
    return undefined;
}
exports.findUpAst = findUpAst;
//# sourceMappingURL=ast-utils.js.map